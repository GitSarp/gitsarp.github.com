<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FreaxJJ</title>
  
  <subtitle>长风破浪会有时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gitsarp.github.io/"/>
  <updated>2018-08-29T15:25:40.679Z</updated>
  <id>http://gitsarp.github.io/</id>
  
  <author>
    <name>FreaxJJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tomcat——持续更新</title>
    <link href="http://gitsarp.github.io/Java/Tomcat/"/>
    <id>http://gitsarp.github.io/Java/Tomcat/</id>
    <published>2018-08-29T15:25:48.000Z</published>
    <updated>2018-08-29T15:25:40.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tomcat—持续更新"><a href="#Tomcat—持续更新" class="headerlink" title="Tomcat—持续更新"></a>Tomcat—持续更新</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/9ccc3ed9de0df39faa1e.jpeg" alt=""><br>Server：指的就是整个 Tomcat 服 务器，包含多组服务，负责<strong>管理和 启动各个 Service</strong>，同时监听 8005 端口发过来的 shutdown 命令，用 于关闭整个容器 ；<br>Service：Tomcat 封装的、对外提 供完整的、基于组件的 web 服务， 包含 Connectors、Container 两个 核心组件，以及多个功能组件，各 个 Service 之间是独立的，但是共享 同一 JVM 的资源 ；<br><strong>Connector</strong>：Tomcat 与外部世界的连接器，监听固定端口接收外部请求，传递给 Container，并 将 Container 处理的结果返回给外部；<br><strong>Container</strong>：Catalina，Servlet 容器，内部有多层容器组成，用于管理 Servlet 生命周期，调用 servlet 相关方法。<br><strong>Loader</strong>：封装了 Java ClassLoader，用于 Container 加载类文件；<br>Realm：Tomcat 中为 web 应用程序提供访问认证和角色管理的机制；<br>JMX：Java SE 中定义技术规范，是一个为应用程序、设备、系统等植入管理功能的框架，通过 JMX 可以<strong>远程监控 Tomcat 的运行状态</strong>；<br><strong>Jasper</strong>：Tomcat 的 Jsp 解析引擎，用于将 Jsp 转换成 Java 文件，并编译成 class 文件。 <strong>Session</strong>：负责管理和创建 session，以及 Session 的持久化(可自定义)，支持 session 的集<br>群。<br><strong>Pipeline</strong>：在容器中充当管道的作用，管道中可以设置各种 valve(阀门)，请求和响应在经由管 道中各个阀门处理，提供了一种灵活可配置的处理请求和响应的机制。<br><strong>Naming</strong>：命名服务，JNDI， Java 命名和目录接口，是一组在 Java 应用中访问命名和目录服务的 API。命名服务将名称和对象联系起来，使得我们可以用名称访问对象，目录服务也是一种命名 服务，对象不但有名称，还有属性。Tomcat 中可以使用 JNDI 定义数据源、配置信息，用于开发 与部署的分离。</p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a><strong>Container</strong></h3><p> <img src="https://lc-mhke0kuv.cn-n1.lcfile.com/1a2613edf5779c7bf184.jpeg" alt=""></p><ul><li>Engine：Servlet 的顶层容器，包含一 个或多个 Host 子容器；</li><li>Host：虚拟主机，<strong>负责 web 应用的部署和 Context 的创建</strong>；</li><li><strong>Context</strong>：Web 应用上下文，包含多个 Wrapper，负责 web 配置的解析、管 理所有的 Web 资源；</li><li>Wrapper：最底层的容器，是<strong>对 Servlet 的封装</strong>，负责 Servlet 实例的创 建、执行和销毁。</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li>Tomcat 为了方便管理组件和容器的生命周期，定义了从创建、启动、到停止、销毁共 12 中状态。组件和容器只需实现相应的生命周期 方法即可完成各生命周期内的操作(initInternal、startInternal、stopInternal、 destroyInternal)<br><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/1ea5e727c9ad4ca37e05.jpeg" alt=""></li><li>Tomcat 的生命周期管理引入了<strong>事件机制</strong>，在组件或容器的生命周期状态发生变化时会通 知事件监听器，<strong>监听器</strong>通过判断事件的类型来进行相应的操作。事件监听器可以在 server.xml 文件中进行配置，Tomcat 各类容器的配置过程就是通过添加 listener 的方式来进行的。<ul><li>EngineConfig：主要打印启动和停止日志</li><li><strong>HostConfig</strong>：主要处理部署应用，解析应用 META-INF/context.xml 并创建应用的 Context   </li><li><strong>ContextConfig</strong>：主要解析并合并 web.xml，扫描应用的各类 web 资源 (filter、servlet、listener)<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/94989563f76b0c2b6b19.jpeg" alt=""><br>所有容器都是继承自 ContainerBase，基类中封装了容器中的重复工作，负责启动容器相关的组 件 Loader、Logger、Manager、Cluster、Pipeline，启动子容器(线程池并发启动子容器，通过 线程池 submit 多个线程，调用后返回 Future 对象，线程内部启动子容器，接着调用 Future 对象 的 get 方法来等待执行结果)。</li></ul></li></ul><h3 id="Web应用部署配置"><a href="#Web应用部署配置" class="headerlink" title="Web应用部署配置"></a>Web应用部署配置</h3><h4 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h4><p><strong>catalina.home</strong>：安装目录; <strong>catalina.base</strong>：工作目录,默认值 user.dir</p><ul><li>修改默认端口(connector的port属性)，添加虚拟主机</li><li>部署外部应用<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--appBase默认\$catalina.base/webapps/--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"应用名"</span> <span class="attr">docBase</span>=<span class="string">"路径"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">   或conf/catalana/localhost下创建   应用名.xml   文件</span><br><span class="line">   <span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"路径"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>HostConfig 监听了 StandardHost 容器的事件，在 start 方法中解析上述配置文件(HostConfig会定期检查context.xml)：</li></ol><ul><li>扫描 appbase 路径下的所有文件夹和 war 包，ContextConfig解析各个应用的 META-INF/context.xml，并 创建 StandardContext，并将 Context 加入到 Host 的子容器中。</li><li>解析$catalina.base/EngineName/HostName/下的所有 Context 配置，找到相应 web 应 用的位置，ContextConfig解析各个应用的 META-INF/context.xml，并创建 StandardContext，并将 Context 加入到 Host 的子容器中。 </li></ul><ol start="2"><li>ContextConfig 解析 context.xml 顺序：</li></ol><ul><li>先解析全局的配置 config/context.xml</li><li>然后解析 Host 的默认配置 EngineName/HostName/context.xml.default</li><li>最后解析应用的 META-INF/context.xml</li></ul><ol start="3"><li>ContextConfig 解析 web.xml 顺序：</li></ol><ul><li>先解析全局的配置 config/web.xml</li><li>然后解析 Host 的默认配置 EngineName/HostName/web.xml.default 接着解析应用的 MEB-INF/web.xml</li><li>扫描应用 WEB-INF/lib/下的 jar 文件，解析其中的 META-INF/web-fragment.xml 最后合并 xml 封装成 WebXml，并设置 Context</li></ul><h3 id="请求处理过程"><a href="#请求处理过程" class="headerlink" title="请求处理过程"></a>请求处理过程</h3><p><img src="https://lc-mhke0kuv.cn-n1.lcfile.com/36a5730697cd0e18a7f5.png" alt=""></p><p><a href="https://juejin.im/post/58eb5fdda0bb9f00692a78fc" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Tomcat—持续更新&quot;&gt;&lt;a href=&quot;#Tomcat—持续更新&quot; class=&quot;headerlink&quot; title=&quot;Tomcat—持续更新&quot;&gt;&lt;/a&gt;Tomcat—持续更新&lt;/h2&gt;&lt;h3 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Java" scheme="http://gitsarp.github.io/categories/Java/"/>
    
    
      <category term="tomcat" scheme="http://gitsarp.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>git基础——持续更新</title>
    <link href="http://gitsarp.github.io/Linux/git/"/>
    <id>http://gitsarp.github.io/Linux/git/</id>
    <published>2018-08-29T15:17:48.000Z</published>
    <updated>2018-09-14T06:34:47.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git基础——持续更新"><a href="#git基础——持续更新" class="headerlink" title="git基础——持续更新"></a>git基础——持续更新</h3><p><a href="https://git-scm.com/docs" target="_blank" rel="noopener">文档</a></p><p><a href="https://git-scm.com/book/zh/v2/" target="_blank" rel="noopener">中文文档</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt=""></p><blockquote><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul></blockquote><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 显示当前的Git配置</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git config --list</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 编辑Git配置文件</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git config -e [--global]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 设置提交代码时的用户信息</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git config [--global] user.name <span class="string">"[name]"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git config [--global] user.email <span class="string">"[email address]"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 将当前或新建目录初始化为Git代码库</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git init [project-dir]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git add *</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># git add LICENSE</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git commit -m <span class="string">'initial project version'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 跳过暂存区</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git commit -a</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 克隆一个项目和它的代码历史</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git <span class="built_in">clone</span> [url]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># git add可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 </span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 显示文件状态</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git status -s</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 新添加的未跟踪文件前面有 ?? 标记，</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 新添加到暂存区中的文件前面有 A 标记</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 出现在右边的 M 表示该文件被修改了但是还没放入暂存区，</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 出现在靠左边的 M 表示该文件被修改了并放入了暂存区。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 查看未暂存的修改</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git diff</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># 查看已暂存的修改</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $ git diff --staged</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment"># git ignore</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> https://github.com/github/gitignore</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>$ git config –global alias.co checkout<br>$ git config –global alias.br branch<br>$ git config –global alias.ci commit<br>$ git config –global alias.st status<br>$ git config –global alias.unstage ‘reset HEAD –’<br>$ git config –global alias.last ‘log -1 HEAD’<br>$ git config –global alias.visual ‘!gitk’外部命令</p><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><ul><li>git remote -v查看所有远程仓库</li><li>git remote show <shortname>查看某个仓库</shortname></li><li>git remote add <shortname> <url> 添加仓库</url></shortname></li><li>$ git fetch <shortname>拉取更新，不自动合并到当前分支</shortname></li><li>$ git pull <shortname>拉取更新，自动合并到当前分支</shortname></li><li>git push origin master推送到仓库</li><li>$ git remote rename oldname newname</li><li>$ git remote rm paul<h4 id="取消暂存"><a href="#取消暂存" class="headerlink" title="取消暂存"></a>取消暂存</h4></li><li>$ git commit –amend这个命令会将暂存区中的文件提交</li><li>$ git reset HEAD <file>… 来取消暂存。</file></li><li>撤销未暂存的修改</li><li>$ git checkout – <file>…</file></li><li>将文件变踢出版本控制</li><li>$ git rm –cached <file></file></li><li>删除已提交暂存区的文件，同时删除本地</li><li>$ git rm</li><li>修改文件名</li><li>$ git mv,如果通过外部mv，需要添加新的文件，踢出旧的文件<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3></li><li>git tag</li><li>$ git tag -l ‘v1.8.5*’查看标签</li><li>$ git tag -a v1.4 -m ‘my version 1.4’打标签</li><li>$ git show v1.4查看具体标签</li><li>$ git tag v1.4-lw打轻量标签</li><li>$ git tag -a v1.2 9fceb02给历史提交打标签，最后的是部分校验和，可用git log查看</li><li>$ git push origin v1.5给远程仓库也打上标签v1.5</li><li><p>$ git push origin –tags给远程仓库同步打上标签</p><h3 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h3><p>git log [options] [– dir]</p></li><li><p>-n显示最近几次的日志，不写为全部</p></li><li>–stat显示哪些文件改变了，增加了几行，减少了几行统计信息</li><li>-p显示修改的内容</li><li>–pretty=oneline一次提交在一行显示</li><li>–pretty=format:”%h - %an, %ar : %s”</li><li>–graph</li><li>–since, –after仅显示指定时间之后的提交。</li><li>–until, –before仅显示指定时间之前的提交。<br>$ git log –since=2.weeks</li><li>–author/–commiter 选项显示指定作者/提交者的提交</li><li>–grep 选项搜索提交说明中的关键字。</li><li>-S查看包含字符串的提交 $ git log -Sfunction_name</li><li>–shortstat只显示 –stat 中最后的行数修改添加移除统计。</li><li>–name-only仅在提交信息后显示已修改的文件清单。</li><li>–name-status显示新增、修改、删除的文件清单。</li><li>–abbrev-commit仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</li><li>–relative-date使用较短的相对时间显示（比如，“2 weeks ago”）。</li><li>$ git log –pretty=”%h - %s” –author=gitster –since=”2008-10-01” \<br> –before=”2008-11-01” –no-merges – t/<br> 查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，</li></ul><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><ol><li>在当前分支上进行了修改，此时需要在原有分支上进行紧急修复</li></ol><ul><li>建立新分支<br>$ git checkout -b iss53<br>Switched to a new branch “iss53”<br>等同于<br>$ git branch iss53<br>$ git checkout iss53</li><li>修改，提交<br>git commit -a -m ‘added a new footer [issue 53]’</li><li>将修改全部提交！</li><li>切回原有分支<br>$ git checkout master<br>Switched to branch ‘master’</li><li>建立分支紧急修复，并提交<br>$ git checkout -b hotfix<br>Switched to a new branch ‘hotfix’<br>$git commit -a -m ‘fixed the broken email address’</li><li>切回主分支并合并紧急修复分支<br>$ git checkout master<br>$ git merge hotfix</li><li>删除紧急分支<br>$ git branch -d hotfix<br>Deleted branch hotfix (3a0874c).</li><li>返回修改工作<br>$ git checkout iss53<br>Switched to branch “iss53”<br>$ git commit -a -m ‘finished the new footer [issue 53]’<br>你在 hotfix 分支上所做的工作并没有包含到 iss53 分支中。 如果你需要拉取 hotfix 所做的修改，你可以使用 <strong>git merge master</strong> 命令将 master 分支合并入 iss53 分支，或者你也可以等到 iss53 分支完成其使命，再将其合并回 master 分支。</li><li>合并到主分支<br>$ git checkout master<br>$ git merge iss53</li><li>删除修改分支<br>$ git branch -d iss53</li></ul><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><ul><li>使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</li><li>在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</li><li>图形化工具来解决冲突，你可以运行 git mergetool（mac默认opendiff ）</li><li>git commit</li></ul><h4 id="Mac删除-DS-Store"><a href="#Mac删除-DS-Store" class="headerlink" title="Mac删除.DS_Store"></a>Mac删除.DS_Store</h4><p>删除<strong>项目中的</strong>所有.DS_Store。</p><ul><li>find . -name .DS_Store -print0 | xargs -0 git rm -f –ignore-unmatch</li><li>echo .DS_Store &gt;&gt; ~/.gitignore</li><li>git commit -m ‘delete .DS_Store’</li><li>git push</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;git基础——持续更新&quot;&gt;&lt;a href=&quot;#git基础——持续更新&quot; class=&quot;headerlink&quot; title=&quot;git基础——持续更新&quot;&gt;&lt;/a&gt;git基础——持续更新&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://git-scm.com/docs&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://gitsarp.github.io/categories/Linux/"/>
    
    
      <category term="git" scheme="http://gitsarp.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>netty——持续更新</title>
    <link href="http://gitsarp.github.io/Java/netty/"/>
    <id>http://gitsarp.github.io/Java/netty/</id>
    <published>2018-08-29T15:15:48.000Z</published>
    <updated>2018-08-29T15:15:15.822Z</updated>
    
    <content type="html"><![CDATA[<h4 id="netty——持续更新"><a href="#netty——持续更新" class="headerlink" title="netty——持续更新"></a>netty——持续更新</h4><ul><li><a href="https://mvnrepository.com/artifact/io.netty" target="_blank" rel="noopener">maven依赖</a></li><li>what is netty?</li></ul><p>The Netty project is an effort to provide an asynchronous event-driven network application framework and tooling for the rapid development of maintainable high-performance · high-scalability protocol servers and clients.</p><h4 id="Get-Start"><a href="#Get-Start" class="headerlink" title="Get Start"></a>Get Start</h4><ul><li>ServerHandler</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DiscardServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void channelRead(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line"><span class="comment">//        ((ByteBuf)msg).release();//discard everything</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//官方说明，msg必须要释放！！！</span></span><br><span class="line"><span class="comment">//        ByteBuf in = (ByteBuf) msg;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            //System.out.println(in.toString(CharsetUtil.US_ASCII));</span></span><br><span class="line"><span class="comment">//            while (in.isReadable()) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println((char) in.readByte());</span></span><br><span class="line"><span class="comment">//                System.out.flush();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125; finally &#123;</span></span><br><span class="line"><span class="comment">//            ReferenceCountUtil.release(msg);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        ctx.write(msg);<span class="comment">//使用ctx则不需要对msg进行释放，netty会帮我们释放</span></span><br><span class="line">        ctx.flush();</span><br><span class="line">        <span class="comment">//ctx.writeAndFlush(msg);//more brevity</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void exceptionCaught(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Throwable</span> cause) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="comment">//the caught exception should be logged and its associated channel should be closed here</span></span><br><span class="line">        <span class="comment">//you might want to send a response message with an error code before closing the connection.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Server</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();<span class="comment">//parent group,accept con</span></span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();<span class="comment">//child group</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();<span class="comment">//server</span></span><br><span class="line">            serverBootstrap.group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)<span class="comment">//channel</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="comment">//init channel</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());<span class="comment">//add handler</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(port).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            port = <span class="number">8080</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> DiscardServer(port).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="http://netty.io/4.1/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="noopener">NioEventLoopGroup</a></li></ul><p>The first one, often called ‘boss’, accepts an incoming connection. The second one, often called ‘worker’, handles the traffic of the accepted connection once the boss accepts the connection and registers the accepted connection to the worker. How many Threads are used and how they are mapped to the created Channels depends on the <strong>EventLoopGroup</strong> implementation and may be even configurable via a constructor.</p><ul><li><a href="http://netty.io/4.1/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="noopener">ServerBootstrap</a></li></ul><p>ServerBootstrap is a helper class that sets up a server. You can set up the server using a Channel directly. However, please note that this is a tedious process, and you do not need to do that in most cases.</p><ul><li><a href="http://netty.io/4.1/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="noopener">ChannelInitializer</a></li></ul><p>The ChannelInitializer is a special handler that is purposed to help a user configure a new Channel. It is most likely that you want to configure the ChannelPipeline of the new Channel by adding some handlers such as DiscardServerHandler to implement your network application. As the application gets complicated, it is likely that you will add more handlers to the pipeline and extract this anonymous class into a top level class eventually.</p><p>Please refer to the apidocs of ChannelOption and the specific ChannelConfig implementations to get an overview about the supported ChannelOptions.</p><p>option() is for the NioServerSocketChannel that accepts incoming connections. childOption() is for the Channels accepted by the parent ServerChannel, </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;netty——持续更新&quot;&gt;&lt;a href=&quot;#netty——持续更新&quot; class=&quot;headerlink&quot; title=&quot;netty——持续更新&quot;&gt;&lt;/a&gt;netty——持续更新&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mvnreposito
      
    
    </summary>
    
      <category term="Java" scheme="http://gitsarp.github.io/categories/Java/"/>
    
    
      <category term="netty" scheme="http://gitsarp.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq</title>
    <link href="http://gitsarp.github.io/Java/rocketmq/"/>
    <id>http://gitsarp.github.io/Java/rocketmq/</id>
    <published>2018-07-16T16:03:19.000Z</published>
    <updated>2018-07-20T12:46:04.746Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://rocketmq.apache.org/docs/quick-start/" target="_blank" rel="noopener">quick-start</a></p><h3 id="物理部署"><a href="#物理部署" class="headerlink" title="物理部署"></a>物理部署</h3><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB18GKUPXXXXXXRXFXXXXXXXXXX" alt="物理部署"></p><ul><li>Name Server是一个<strong>几乎无状态</strong>节点，可集群部署，<strong>节点之间无任何信息同步</strong>。</li><li>Broker分为Master与Slave(<strong>主从配置</strong>)，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定<strong>相同的BrokerName</strong>，不同的BrokerId来定义，<strong>BrokerId为0表示Master，非0表示Slave</strong>。Master也可以部署多个。每个Broker与Name Server集群中的所有节点建立长连接，定时<strong>注册Topic信息到所有Name Server</strong>。</li><li>Producer与Name Server集群中的其中<strong>一个节点（随机选择）建立长连接</strong>，定期从Name Server<strong>取Topic路由信息</strong>，并向提供Topic服务的<strong>Master建立长连接</strong>，且定时向Master发送心跳。<strong>Producer完全无状态</strong>，可集群部署</li><li>Consumer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</li></ul><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>4.2.0版本：</p><ul><li>git clone <a href="https://github.com/apache/rocketmq.git" target="_blank" rel="noopener">https://github.com/apache/rocketmq.git</a></li><li>编译 mvn -Prelease-all -DskipTests clean install -U<br>旧版本：</li><li>git clone <a href="https://github.com/apache/incubator-rocketmq.git" target="_blank" rel="noopener">https://github.com/apache/incubator-rocketmq.git</a></li><li>mvn clean package install -Prelease-all assembly:assembly -U</li></ul><p>注意安装要求，maven是3.2.X否则可能会有问题(我的3.5.3运行quickstart的Consumer就有问题)</p><p>启动关闭:<br>cd distribution/target/apache-rocketmq</p><ul><li>nohup sh bin/mqnamesrv &amp;</li><li>nohup sh bin/mqbroker -n localhost:9876 autoCreateTopicEnable=true &amp;,不加<strong>autoCreateTopicEnable=true</strong>我这边启动Producer报No route info of this topic错</li><li>使用tail -f ~/logs/rocketmqlogs/XXX.log或jps查看是否启动成功，Ctrl c退出</li><li>使用sh bin/mqshutdown broker和sh bin/mqshutdown namesrv关闭</li></ul><h3 id="jar包依赖"><a href="#jar包依赖" class="headerlink" title="jar包依赖"></a>jar包依赖</h3><p><a href="https://mvnrepository.com/artifact/org.apache.rocketmq" target="_blank" rel="noopener">maven</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">commons-cli-1</span><span class="selector-class">.2</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">commons-lang3-3</span><span class="selector-class">.4</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">fastjson-1</span><span class="selector-class">.2</span><span class="selector-class">.29</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">guava-19</span><span class="selector-class">.0</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">javassist-3</span><span class="selector-class">.20</span><span class="selector-class">.0-GA</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">jna-4</span><span class="selector-class">.2</span><span class="selector-class">.2</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">logback-classic-1</span><span class="selector-class">.0</span><span class="selector-class">.13</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">logback-core-1</span><span class="selector-class">.0</span><span class="selector-class">.13</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">netty-all-4</span><span class="selector-class">.0</span><span class="selector-class">.36</span><span class="selector-class">.Final</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">openmessaging-api-0</span><span class="selector-class">.1</span><span class="selector-class">.0-alpha</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">rocketmq-client-4</span><span class="selector-class">.2</span><span class="selector-class">.0-incubating-SNAPSHOT</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">rocketmq-common-4</span><span class="selector-class">.2</span><span class="selector-class">.0-incubating-SNAPSHOT</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">rocketmq-remoting-4</span><span class="selector-class">.2</span><span class="selector-class">.0-incubating-SNAPSHOT</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">rocketmq-srvutil-4</span><span class="selector-class">.2</span><span class="selector-class">.0-incubating-SNAPSHOT</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">rocketmq-tools-4</span><span class="selector-class">.2</span><span class="selector-class">.0-incubating-SNAPSHOT</span><span class="selector-class">.jar</span></span><br><span class="line"><span class="selector-tag">slf4j-api-1</span><span class="selector-class">.7</span><span class="selector-class">.5</span><span class="selector-class">.jar</span></span><br></pre></td></tr></table></figure><h3 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h3><ul><li>同步——用在大规模分布场景下，像重要的通知消息，短信通知，短信市场系统等</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span></span><br><span class="line">            DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.<span class="built_in">printf</span>(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异步——实时的业务场景</li></ul><p>可以看出多了发送完的回调函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">                    <span class="string">"TagA"</span>,</span><br><span class="line">                    <span class="string">"OrderID188"</span>,</span><br><span class="line">                    <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, index, e);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单向传输——对可靠性要求一般的场景，像日志搜集</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> <span class="type">DefaultMQProducer</span>(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> <span class="type">Message</span>(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            producer.sendOnew<span class="type">ay</span>(msg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><p> <img src="http://img3.tbcdn.cn/5476e8b07b923/TB1rdyvPXXXXXcBapXXXXXXXXXX" alt=""></p><ul><li>队列集合称为Topic，Consumer如果做广播消费，则一个consumer实例消费这个Topic对应的所有队列，如果做集群消费，则多个Consumer实例平均消费这个topic对应的队列集合。</li></ul><h4 id="有序消息"><a href="#有序消息" class="headerlink" title="有序消息"></a>有序消息</h4><h5 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h5><p>从运行结果看，默认四条消息队列(queueid0-3)。消息的id(0~9)会发送到不同的消息队列上</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main( <span class="keyword">String</span>[] args ) <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">    MQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"example_group_name"</span>);</span><br><span class="line">    <span class="comment">//Launch the instance.</span></span><br><span class="line">    <span class="comment">//多个地址用分号隔开；也可以设置成环境变量</span></span><br><span class="line">    ((DefaultMQProducer) producer).setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="keyword">String</span>[] tags = <span class="keyword">new</span> <span class="keyword">String</span>[] &#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>, <span class="string">"TagD"</span>, <span class="string">"TagE"</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">int</span> orderId = i % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTestjjj"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, <span class="keyword">Object</span> arg) &#123;</span><br><span class="line">                Integer id = (Integer) arg;</span><br><span class="line">                <span class="comment">//输出0~9</span></span><br><span class="line">                <span class="comment">//System.out.println(id);</span></span><br><span class="line">                <span class="built_in">int</span> index = id % mqs.<span class="built_in">size</span>();<span class="comment">// 如果队列数不变，同一个订单号取到的队列是同一个 </span></span><br><span class="line">                <span class="keyword">return</span> mqs.<span class="built_in">get</span>(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, orderId);<span class="comment">//orderId传递给回调方法</span></span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//server shutdown</span></span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h5><p><img src="/images/mqqueue.png" alt="20160420114245543"></p><p>消费者消费指定主题的消息，并注册监听器，打印消息并根据收到的消息顺序返回不同的消费状态</p><ul><li>实现<strong>MessageListenerOrderly</strong>的consumeMessage方法</li><li>CONSUME_FROM_LAST_OFFSET：第一次启动从队列最后位置消费，后续再启动接着上次消费的进度开始消费 </li><li>CONSUME_FROM_FIRST_OFFSET：第一次启动从队列初始位置消费，后续再启动接着上次消费的进度开始消费 </li><li>CONSUME_FROM_TIMESTAMP：第一次启动从指定时间点位置消费，后续再启动接着上次消费的进度开始消费 </li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static void main (String[] args) throws Exception &#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(<span class="string">"example_group_name"</span>);</span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">    consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"TagA || TagC || TagD"</span>);</span><br><span class="line"></span><br><span class="line">    consumer.registerMessageListener(new MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">        AtomicLong consumeTimes = new AtomicLong(<span class="number">0</span>);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,</span><br><span class="line">                                                   ConsumeOrderlyContext context) &#123;</span><br><span class="line">            context.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.printf(Thread.currentThread().getName() + <span class="string">" Receive New Messages: "</span> + msgs + <span class="string">"%n"</span>);</span><br><span class="line">            <span class="keyword">this</span>.consumeTimes.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.<span class="keyword">get</span>() % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.<span class="keyword">get</span>() % <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.ROLLBACK;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.<span class="keyword">get</span>() % <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.COMMIT;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.<span class="keyword">get</span>() % <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                context.setSuspendCurrentQueueTimeMillis(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    consumer.start();</span><br><span class="line"></span><br><span class="line">    System.<span class="keyword">out</span>.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h4><ul><li>消费者设置：<pre><code>//set to broadcast modeconsumer.setMessageModel(MessageModel.BROADCASTING);</code></pre></li></ul><h4 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h4><ol><li>生产者</li></ol><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This message will be delivered to consumer 10 seconds later.</span></span><br><span class="line">   <span class="keyword">message</span>.setDelayTimeLevel(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>消费者<br>消费者监听器中可以取得消息的存储时间，进而可以计算出延迟的时间</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (MessageExt message : <span class="type">messages</span>) &#123;</span><br><span class="line">                    // Print approximate <span class="keyword">delay</span> time period</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"Receive message[msgId="</span> + message.getMsgId() + <span class="string">"] "</span></span><br><span class="line">                            + (System.currentTimeMillis() - message.getStoreTimestamp()) + <span class="string">"ms later"</span>);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><h4 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h4><ul><li>能够提高小的消息的传送效率</li><li>限制1：same topic, same waitStoreMsgOK and no schedule support.</li><li>限制2：the total size of the messages in one batch should be no more than 1MiB.</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> topic = <span class="string">"BatchTest"</span>;</span><br><span class="line">List&lt;Message&gt; messages = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">messages.add(<span class="keyword">new</span> <span class="type">Message</span>(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID001"</span>, <span class="string">"Hello world 0"</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> <span class="type">Message</span>(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID002"</span>, <span class="string">"Hello world 1"</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> <span class="type">Message</span>(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID003"</span>, <span class="string">"Hello world 2"</span>.getBytes()));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    producer.send(messages);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//handle the error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>太大则需要分块生产</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ListSplitter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">List</span>&lt;<span class="title">Message</span>&gt;&gt; </span>&#123;</span><br><span class="line">    private <span class="keyword">final</span> <span class="built_in">int</span> SIZE_LIMIT = <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">    private <span class="keyword">final</span> <span class="built_in">List</span>&lt;Message&gt; messages;</span><br><span class="line">    private <span class="built_in">int</span> currIndex;</span><br><span class="line">    public ListSplitter(<span class="built_in">List</span>&lt;Message&gt; messages) &#123;</span><br><span class="line">            <span class="keyword">this</span>.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> public boolean hasNext() &#123;</span><br><span class="line">        <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> public <span class="built_in">List</span>&lt;Message&gt; next() &#123;</span><br><span class="line">        <span class="built_in">int</span> nextIndex = currIndex;</span><br><span class="line">        <span class="built_in">int</span> totalSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">            Message message = messages.<span class="keyword">get</span>(nextIndex);</span><br><span class="line">            <span class="built_in">int</span> tmpSize = message.getTopic().length() + message.getBody().length;</span><br><span class="line">            <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; properties = message.getProperties();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">Map</span>.Entry&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                tmpSize += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">            &#125;</span><br><span class="line">            tmpSize = tmpSize + <span class="number">20</span>; <span class="comment">//for log overhead</span></span><br><span class="line">            <span class="keyword">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                <span class="comment">//it is unexpected that single message exceeds the SIZE_LIMIT</span></span><br><span class="line">                <span class="comment">//here just let it go, otherwise it will block the splitting process这里直接让这个单独的“大”消息过去，否则会阻塞拆分的进程</span></span><br><span class="line">                <span class="keyword">if</span> (nextIndex - currIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">//if the next sublist has no element, add this one and then break, otherwise just break如果下个子列表没有元素，则把这个“大”消息加进去，并把nextIndex+1</span></span><br><span class="line">                   nextIndex++;  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                totalSize += tmpSize;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">List</span>&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line">        currIndex = nextIndex;</span><br><span class="line">        <span class="keyword">return</span> subList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//then you could split the large list into small ones:</span></span><br><span class="line">ListSplitter splitter = <span class="keyword">new</span> ListSplitter(messages);</span><br><span class="line"><span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="built_in">List</span>&lt;Message&gt;  listItem = splitter.next();</span><br><span class="line">       producer.send(listItem);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">       <span class="comment">//handle the error</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息过滤选择"><a href="#消息过滤选择" class="headerlink" title="消息过滤选择"></a>消息过滤选择</h4><ul><li>一条消息只能有一个tag，因此通过consumer.subscribe(“TOPIC”, “TAGA || TAGB || TAGC”);这种方式的选择性不强</li><li>可以通过向message中添加1到n条属性，消费者对属性或属性组合进行逻辑判断来过滤消息</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者Set some properties.</span></span><br><span class="line">msg.putUserProperty(<span class="string">"a"</span>, <span class="keyword">String</span>.valueOf(i));</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, MessageSelector.bySql(<span class="string">"a between 0 and 3"</span>);</span><br></pre></td></tr></table></figure><h4 id="OpenMessaging国际标准"><a href="#OpenMessaging国际标准" class="headerlink" title="OpenMessaging国际标准"></a>OpenMessaging国际标准</h4><p><a href="https://openmessaging.github.io/" target="_blank" rel="noopener">OpenMessaging</a></p><p><a href="https://www.csdn.net/article/a/2017-10-18/15933580" target="_blank" rel="noopener">新闻</a></p><h4 id="Logappender日志"><a href="#Logappender日志" class="headerlink" title="Logappender日志"></a>Logappender日志</h4><h4 id="Transaction事务处理"><a href="#Transaction事务处理" class="headerlink" title="Transaction事务处理"></a>Transaction事务处理</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://rocketmq.apache.org/docs/quick-start/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;quick-start&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;物理部署&quot;&gt;&lt;a href=&quot;#物理部署&quot; 
      
    
    </summary>
    
      <category term="Java" scheme="http://gitsarp.github.io/categories/Java/"/>
    
    
      <category term="rocketmq" scheme="http://gitsarp.github.io/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>Java socket编程</title>
    <link href="http://gitsarp.github.io/Java/Socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://gitsarp.github.io/Java/Socket编程/</id>
    <published>2018-07-11T14:13:38.000Z</published>
    <updated>2018-07-16T16:10:26.020Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传统阻塞方式"><a href="#传统阻塞方式" class="headerlink" title="传统阻塞方式"></a>传统阻塞方式</h3><p>直接上代码</p><ul><li><p>客户端</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class MyClient &#123;</span><br><span class="line">    <span class="keyword">String</span> host;</span><br><span class="line">    <span class="built_in">int</span> port;</span><br><span class="line">    Socket socket;</span><br><span class="line">    <span class="built_in">int</span> timeOut=<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">BufferedReader</span> bufferedReader;</span><br><span class="line">    PrintStream printStream;</span><br><span class="line">    <span class="keyword">BufferedReader</span> receive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClient(<span class="keyword">String</span> host, <span class="built_in">int</span> port) &#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket=<span class="keyword">new</span> Socket(host,port);</span><br><span class="line">            socket.setSoTimeout(timeOut);<span class="comment">//设置接收响应的超时时间</span></span><br><span class="line">            bufferedReader=<span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(System.in));<span class="comment">//用户输入</span></span><br><span class="line">            printStream=<span class="keyword">new</span> PrintStream(socket.getOutputStream());<span class="comment">//响应流</span></span><br><span class="line">            receive=<span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));<span class="comment">//响应流</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> sendAndReceive() <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="built_in">boolean</span> bye=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">String</span> message;</span><br><span class="line">        <span class="keyword">while</span> (!bye)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"input your message..."</span>);</span><br><span class="line">            message=bufferedReader.readLine();</span><br><span class="line">            <span class="keyword">if</span>(message.equals(<span class="string">""</span>)||message.isEmpty())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(message.equals(<span class="string">"bye"</span>))</span><br><span class="line">                bye=<span class="keyword">true</span>;</span><br><span class="line">            printStream.<span class="built_in">println</span>(message);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                message=receive.readLine();</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"receive:"</span>+message);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">"response timeout"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printStream.close();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">        MyClient myClient=<span class="keyword">new</span> MyClient(<span class="string">"127.0.0.1"</span>,<span class="number">8085</span>);</span><br><span class="line">        <span class="comment">//MyClient myClient2=new MyClient("127.0.0.1",8085);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myClient.sendAndReceive();</span><br><span class="line">            <span class="comment">//myClient2.sendAndReceive();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务端线程</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class MyServerThread implements Runnable&#123;</span><br><span class="line">    Socket client;</span><br><span class="line">    BufferedReader req;</span><br><span class="line">    String reqMsg;</span><br><span class="line">    PrintStream out;</span><br><span class="line"></span><br><span class="line">    public MyServerThread(Socket client) &#123;</span><br><span class="line">        this.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="builtin-name">run</span>() &#123;</span><br><span class="line">        boolean <span class="attribute">endFlag</span>=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (endFlag)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="attribute">req</span>=new BufferedReader(new InputStreamReader(client.getInputStream()));</span><br><span class="line">                <span class="attribute">reqMsg</span>=req.readLine();</span><br><span class="line">                <span class="keyword">if</span>(<span class="attribute">reqMsg</span>==null||reqMsg.equals("bye"))</span><br><span class="line">                    <span class="attribute">endFlag</span>=<span class="literal">false</span>;</span><br><span class="line">                <span class="attribute">out</span>=new PrintStream(client.getOutputStream());</span><br><span class="line">                out.println(<span class="string">"server resp:"</span>+reqMsg);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="attribute">endFlag</span>=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        try &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务端</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        Socket <span class="keyword">client</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serversocket = <span class="keyword">new</span> ServerSocket(<span class="number">8085</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">client</span>=serversocket.accept();</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyServerThread(<span class="keyword">client</span>)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;传统阻塞方式&quot;&gt;&lt;a href=&quot;#传统阻塞方式&quot; class=&quot;headerlink&quot; title=&quot;传统阻塞方式&quot;&gt;&lt;/a&gt;传统阻塞方式&lt;/h3&gt;&lt;p&gt;直接上代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;客户端&lt;/p&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="Java" scheme="http://gitsarp.github.io/categories/Java/"/>
    
    
      <category term="JavaSocket" scheme="http://gitsarp.github.io/tags/JavaSocket/"/>
    
  </entry>
  
  <entry>
    <title>JVM命令</title>
    <link href="http://gitsarp.github.io/Java/JVM2/"/>
    <id>http://gitsarp.github.io/Java/JVM2/</id>
    <published>2018-07-11T14:08:08.000Z</published>
    <updated>2018-07-30T13:13:10.030Z</updated>
    
    <content type="html"><![CDATA[<h4 id="常用java命令"><a href="#常用java命令" class="headerlink" title="常用java命令"></a>常用java命令</h4><ol><li>jps——查看虚拟机进程信息<br>jps [options]<hostid><br><img src="/images/jps.png" alt=""></hostid></li></ol><ul><li>第一列是VMpid，第二列class或jar的名称</li><li>hostid指定主机，不写为当前机器，格式   [protocol:]&lt;&lt;//&gt;hostname&gt;&lt;:port&gt;</li><li>q：仅显示lvmid；</li><li><strong>-m</strong>:输出主函数传入的参数；</li><li><strong>-l</strong>: 输出应用程序主类完整package名称或jar完整名称；</li><li><strong>-v</strong>: 输出jvm启动时指定的jvm参数；</li><li>-V: 输出通过.hotsportrc或-XX:Flags=<filename>指定的jvm参数</filename></li></ul><p>2.jstat——显示虚拟机运行时状态信息<br>jstat [options] <lvmid> [intervals[s|ms]] [count]<br>intervals：输出间隔时间<br>count：输出总次数<br>option参数：</lvmid></p><ul><li>class 加载class的数量，字节大小和未加载的class数量大小以及加载时间<br>$ jstat -class 11589<br>Loaded  Bytes  Unloaded  Bytes     Time<br>7035  14506.3     0     0.0       3.67</li><li>compiler HotSpot JIT编译器行为统计<br>$ jstat -compiler 1262<br>Compiled Failed Invalid   Time   FailedType FailedMethod<br>  2573      1       0    47.60          1 org/apache/catalina/loader/WebappClassLoader findResourceInternal</li><li><p>gc 分别输出survivoro、Eden和老年代的空间和已用空间大小，以及年轻代和老年代gc的次数，耗时以及gc总耗时<br>$ jstat -gc 1262<br>S0C    S1C     S0U     S1U   EC       EU        OC         OU        PC       PU         YGC    YGCT    FGC    FGCT     GCT<br>26112.0 24064.0 6562.5  0.0   564224.0 76274.5   434176.0   388518.3  524288.0 42724.7    320    6.417   1      0.398    6.815</p></li><li><p>gccapacity 除上条输出信息外，还输出每个堆区域的最小（大）空间限制<br>$ jstat -gccapacity 1262<br>NGCMN    NGCMX     NGC    S0C   S1C       EC         OGCMN      OGCMX      OGC        OC       PGCMN    PGCMX     PGC      PC         YGC    FGC<br>614400.0 614400.0 614400.0 26112.0 24064.0 564224.0   434176.0   434176.0   434176.0   434176.0 524288.0 1048576.0 524288.0 524288.0    320     1</p></li><li>gccasue 同gcutil，和最后一次执行gc的原因以及当前执行gc的原因<br>$ jstat -gccause 28920<br>S0     S1     E      O      P       YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC<br>12.45   0.00  33.85   0.00   4.44      4    0.242     0    0.000    0.242   Allocation Failure   No GC</li><li>gcnew 输出新生代空间的gc性能数据</li><li>gcnewcapacity 新生代空间大小的统计数据</li><li>gcold 老年代空间的gc性能数据</li><li>gcoldcapacity 老年代空间大小的统计数据</li><li>gcpermcapacity 持久代的空间大小统计数据</li><li>gcutil 同gc，只不过输出的是已使用空间占总空间的百分比<br>$ jstat -gcutil 28920<br>S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT<br>12.45   0.00  33.85   0.00   4.44  4       0.242     0    0.000    0.242</li><li>printcompilation HotSpot编译方法统计</li></ul><ol start="3"><li>jstack——查看线程调用栈信息<br>jstack [option] LVMID</li></ol><ul><li>LVMID:jps命令，或将占用cpu或其他资源多的pid找出来(可以通过top命令)，然后转成16进制的数，即为lvmid</li><li><em>-F</em> : 当正常输出请求不被响应时，强制输出线程堆栈</li><li><strong>-l</strong> : 除堆栈外，显示关于锁的附加信息</li><li><strong>-m</strong> : 如果调用到本地方法的话，可以显示C/C++的堆栈<br><img src="https://upload-images.jianshu.io/upload_images/2184951-311ab1b4ea7dde3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></li></ul><ol start="4"><li>jmap [ -option ] <lvmid>–生成heap dump文件</lvmid></li></ol><ul><li>dump,-dump[:live,]format=b,file=<filename>,live说明是否只dump存活的对象.或者使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件</filename></li><li>heap 显示堆详细信息，如使用哪种回收器、参数配置、分代情况等</li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap <span class="number">28920</span></span><br><span class="line">  Attaching to process ID <span class="number">28920</span>, please wait...</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line">  Server compiler detected.</span><br><span class="line">  JVM version is <span class="number">24.71</span>-b01  </span><br><span class="line"> </span><br><span class="line">  using thread-local object allocation.</span><br><span class="line">  Parallel GC <span class="keyword">with</span> <span class="number">4</span> thread(s)//GC 方式  </span><br><span class="line"> </span><br><span class="line">  Heap Configuration: //堆内存初始化配置</span><br><span class="line">     <span class="attr">MinHeapFreeRatio</span> = <span class="number">0</span> //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default <span class="number">40</span>)</span><br><span class="line">     <span class="attr">MaxHeapFreeRatio</span> = <span class="number">100</span> //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default <span class="number">70</span>)</span><br><span class="line">     <span class="attr">MaxHeapSize</span>      = <span class="number">2082471936</span> (<span class="number">1986.0</span>MB) //对应jvm启动参数-XX:<span class="attr">MaxHeapSize=设置JVM堆的最大大小</span></span><br><span class="line">     <span class="attr">NewSize</span>          = <span class="number">1310720</span> (<span class="number">1.25</span>MB)//对应jvm启动参数-XX:<span class="attr">NewSize=设置JVM堆的‘新生代’的默认大小</span></span><br><span class="line">     <span class="attr">MaxNewSize</span>       = <span class="number">17592186044415</span> MB//对应jvm启动参数-XX:<span class="attr">MaxNewSize=设置JVM堆的‘新生代’的最大大小</span></span><br><span class="line">     <span class="attr">OldSize</span>          = <span class="number">5439488</span> (<span class="number">5.1875</span>MB)//对应jvm启动参数-XX:<span class="attr">OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span></span><br><span class="line">     <span class="attr">NewRatio</span>         = <span class="number">2</span> //对应jvm启动参数-XX:<span class="attr">NewRatio=:‘新生代’和‘老生代’的大小比率</span></span><br><span class="line">     <span class="attr">SurvivorRatio</span>    = <span class="number">8</span> //对应jvm启动参数-XX:<span class="attr">SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值</span> </span><br><span class="line">     <span class="attr">PermSize</span>         = <span class="number">21757952</span> (<span class="number">20.75</span>MB)  //对应jvm启动参数-XX:<span class="attr">PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span></span><br><span class="line">     <span class="attr">MaxPermSize</span>      = <span class="number">85983232</span> (<span class="number">82.0</span>MB)//对应jvm启动参数-XX:<span class="attr">MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span></span><br><span class="line">     <span class="attr">G1HeapRegionSize</span> = <span class="number">0</span> (<span class="number">0.0</span>MB)  </span><br><span class="line"> </span><br><span class="line">  Heap Usage://堆内存使用情况</span><br><span class="line">  PS Young Generation</span><br><span class="line">  Eden Space://Eden区内存分布</span><br><span class="line">     <span class="attr">capacity</span> = <span class="number">33030144</span> (<span class="number">31.5</span>MB)//Eden区总容量</span><br><span class="line">     <span class="attr">used</span>     = <span class="number">1524040</span> (<span class="number">1.4534378051757812</span>MB)  //Eden区已使用</span><br><span class="line">     <span class="attr">free</span>     = <span class="number">31506104</span> (<span class="number">30.04656219482422</span>MB)  //Eden区剩余容量</span><br><span class="line">     <span class="number">4.614088270399305</span>% used //Eden区使用比率</span><br><span class="line">  From Space:  //其中一个Survivor区的内存分布</span><br><span class="line">     <span class="attr">capacity</span> = <span class="number">5242880</span> (<span class="number">5.0</span>MB)</span><br><span class="line">     <span class="attr">used</span>     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">     <span class="attr">free</span>     = <span class="number">5242880</span> (<span class="number">5.0</span>MB)</span><br><span class="line">     <span class="number">0.0</span>% used</span><br><span class="line">  To Space:  //另一个Survivor区的内存分布</span><br><span class="line">     <span class="attr">capacity</span> = <span class="number">5242880</span> (<span class="number">5.0</span>MB)</span><br><span class="line">     <span class="attr">used</span>     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">     <span class="attr">free</span>     = <span class="number">5242880</span> (<span class="number">5.0</span>MB)</span><br><span class="line">     <span class="number">0.0</span>% used</span><br><span class="line">  PS Old Generation //当前的Old区内存分布</span><br><span class="line">     <span class="attr">capacity</span> = <span class="number">86507520</span> (<span class="number">82.5</span>MB)</span><br><span class="line">     <span class="attr">used</span>     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">     <span class="attr">free</span>     = <span class="number">86507520</span> (<span class="number">82.5</span>MB)</span><br><span class="line">     <span class="number">0.0</span>% used</span><br><span class="line">  PS Perm Generation//当前的 “永生代” 内存分布</span><br><span class="line">     <span class="attr">capacity</span> = <span class="number">22020096</span> (<span class="number">21.0</span>MB)</span><br><span class="line">     <span class="attr">used</span>     = <span class="number">2496528</span> (<span class="number">2.3808746337890625</span>MB)</span><br><span class="line">     <span class="attr">free</span>     = <span class="number">19523568</span> (<span class="number">18.619125366210938</span>MB)</span><br><span class="line">     <span class="number">11.337498256138392</span>% used  </span><br><span class="line"> </span><br><span class="line">  <span class="number">670</span> interned Strings occupying <span class="number">43720</span> bytes.</span><br></pre></td></tr></table></figure><ul><li>finalizerinfo 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</li><li>histo 显示堆中对象统计信息，包括类，实例数量和合计数量</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -histo:live 28920 | more</span><br><span class="line"><span class="code"> num     #instances         #bytes  class name</span></span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="code">   1:         83613       12012248  &lt;constMethodKlass&gt;</span></span><br><span class="line"><span class="code">   2:         23868       11450280  [B</span></span><br><span class="line"><span class="code">   3:         83613       10716064  &lt;methodKlass&gt;</span></span><br><span class="line"><span class="code">   4:         76287       10412128  [C</span></span><br><span class="line"><span class="code">   5:          8227        9021176  &lt;constantPoolKlass&gt;</span></span><br><span class="line"><span class="code">   6:          8227        5830256  &lt;instanceKlassKlass&gt;</span></span><br><span class="line"><span class="code">   7:          7031        5156480  &lt;constantPoolCacheKlass&gt;</span></span><br><span class="line"><span class="code">   8:         73627        1767048  java.lang.String</span></span><br><span class="line"><span class="code">   9:          2260        1348848  &lt;methodDataKlass&gt;</span></span><br><span class="line"><span class="code">  10:          8856         849296  java.lang.Class</span></span><br></pre></td></tr></table></figure><p>class name:<br>B  byte<br>C  char<br>D  double<br>F  float<br>I  int<br>J  long<br>Z  boolean<br>[  数组，如[I表示int[]<br>[L+类名 其他对象</p><ul><li>permstat 打印永久代统计信息</li><li><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -permstat 28920</span><br><span class="line">  Attaching <span class="keyword">to</span> process ID 28920, please wait<span class="built_in">..</span>.</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line"> <span class="built_in"> Server </span>compiler detected.</span><br><span class="line">  JVM version is 24.71-b01</span><br><span class="line">  finding class loader instances <span class="built_in">..</span>done.</span><br><span class="line">  computing per loader stat <span class="built_in">..</span>done.</span><br><span class="line">  please wait<span class="built_in">..</span> computing liveness.liveness analysis may be inaccurate <span class="built_in">..</span>.</span><br><span class="line"> </span><br><span class="line">  class_loader            classes bytes   parent_loader           alive? <span class="built_in"> type </span> </span><br><span class="line">  &lt;bootstrap&gt;             3111    18154296          <span class="literal">null</span>          live    &lt;internal&gt;</span><br><span class="line">  0x0000000600905cf8      1       1888    0x0000000600087f08      dead    sun/reflect/DelegatingClassLoader@0x00000007800500a0</span><br><span class="line">  0x00000006008fcb48      1       1888    0x0000000600087f08      dead    sun/reflect/DelegatingClassLoader@0x00000007800500a0</span><br><span class="line">  0x00000006016db798      0       0       0x00000006008d3fc0      dead    java/util/ResourceBundle<span class="variable">$RBClassLoader</span>@0x0000000780626ec0</span><br><span class="line">  0x00000006008d6810      1       3056      <span class="literal">null</span>          dead    sun/reflect/DelegatingClassLoader@0x00000007800500a0</span><br></pre></td></tr></table></figure></li><li><p>F当-dump没有响应时，强制生成dump快照</p></li></ul><ol start="5"><li>jhat(JVM Heap Analysis Tool)，用来分析jmap 生成的dump(耗费资源，一般将服务器的dump拷贝下来分析，MAT分析比jhat更好点)<br>jhat [dumpfile]<br>$ jhat -J-Xmx512m dump.hprof<br>浏览器访问Http://localhost:7000即可</li><li>jinfo   jps -v口令只能查看到显式指定的参数，如果想要查看未被显式指定的参数的值<br>jinfo [option] [args] LVMID<br>-flag : 输出指定args参数的值<br>-flags : 不需要args参数，输出所有JVM参数的值<br>-sysprops : 输出系统属性，等同于System.getProperties()</li><li>jdps<br>jdps <options> &lt;classses…&gt;<br>用来分析.class文件,目录或jar文件的路径名<blockquote><p>jdps -R -doutput ~/tmp HelloWorld.class<br>jdps -p java.lang xxx.jar<br>查看jar包的所有package(模块信息)<br>jdps –inverse –require java.lang(jdk9以上)<br>查看当前目录和环境路径下那些包依赖指定的包</p></blockquote><h3 id="JVM参数配置分析"><a href="#JVM参数配置分析" class="headerlink" title="JVM参数配置分析"></a>JVM参数配置分析</h3></options></li></ol><p>配置文件位置：eclipse.ini、TOMCAT_HOME/bin/catalina.sh（.bat）、idea有-vm option</p><p><a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;常用java命令&quot;&gt;&lt;a href=&quot;#常用java命令&quot; class=&quot;headerlink&quot; title=&quot;常用java命令&quot;&gt;&lt;/a&gt;常用java命令&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;jps——查看虚拟机进程信息&lt;br&gt;jps [options]&lt;hostid&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://gitsarp.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://gitsarp.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Servlet和Sping过滤器</title>
    <link href="http://gitsarp.github.io/Spring/Sping%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://gitsarp.github.io/Spring/Sping过滤器/</id>
    <published>2018-07-09T13:37:34.000Z</published>
    <updated>2018-07-11T14:41:52.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Servlet容器与Tomcat"><a href="#Servlet容器与Tomcat" class="headerlink" title="Servlet容器与Tomcat"></a>Servlet容器与Tomcat</h2><p>Tomcat 的容器等级中，Context 容器是直接管理 Servlet 在容器中的包装类 Wrapper，所以 Context 容器如何运行将直接影响 Servlet 的工作方式（一个 Context容器对应一个 Web 应用（工程），也就是Servlet 运行时的 Servlet 容器）。<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/image002.jpg" alt="Tomcat 的容器等级"></p><ul><li><p>Tomcat 的配置文件中配置应用</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context <span class="attribute">path</span>=<span class="string">"/projectOne "</span> <span class="attribute">docBase</span>=<span class="string">"D:\projects\projectOne"</span></span><br><span class="line"><span class="attribute">reloadable</span>=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure></li><li><p>tomcat添加一个应用</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tomcat tomcat = getTomcatInstance()<span class="comment">; </span></span><br><span class="line">File appDir = new File(getBuildDirectory(), <span class="string">"webapps/examples"</span>)<span class="comment">; </span></span><br><span class="line">tomcat.<span class="keyword">addWebapp(null, </span><span class="string">"/examples"</span>, appDir.getAbsolutePath())<span class="comment">; </span></span><br><span class="line">tomcat.start()<span class="comment">; </span></span><br><span class="line"><span class="keyword">ByteChunk </span>res = getUrl(<span class="string">"http://localhost:"</span> + getPort() + </span><br><span class="line">              <span class="string">"/examples/servlets/servlet/HelloWorldExample"</span>)<span class="comment">; </span></span><br><span class="line">assertTrue(res.toString().indexOf(<span class="string">"&lt;h1&gt;Hello World!&lt;/h1&gt;"</span>) &gt; <span class="number">0</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Tomcat.addWebapp</span></span><br><span class="line"><span class="keyword">public</span> Context addWebapp(Host host, <span class="keyword">String</span> url, <span class="keyword">String</span> path) &#123; </span><br><span class="line">       silence(url); </span><br><span class="line">       Context ctx = <span class="keyword">new</span> <span class="type">StandardContext</span>();<span class="comment">//创建一个容器 </span></span><br><span class="line">       ctx.setPath( url );<span class="comment">//访问地址，和配置文件中一致 </span></span><br><span class="line">       ctx.setDocBase(path);<span class="comment">//实际地址，和配置文件中一致 </span></span><br><span class="line">       <span class="keyword">if</span> (defaultRealm == <span class="literal">null</span>) &#123; </span><br><span class="line">           initSimpleAuth(); </span><br><span class="line">       &#125; </span><br><span class="line">       ctx.setRealm(defaultRealm); </span><br><span class="line">       ctx.addLifecycleListener(<span class="keyword">new</span> <span class="type">DefaultWebXmlListener</span>()); </span><br><span class="line">       ContextConfig ctxCfg = <span class="keyword">new</span> <span class="type">ContextConfig</span>();<span class="comment">//这个类将会负责整个 Web 应用配置的解析工作 </span></span><br><span class="line">       ctx.addLifecycleListener(ctxCfg); </span><br><span class="line">       ctxCfg.setDefaultWebXml(<span class="string">"org/apache/catalin/startup/NO_DEFAULT_XML"</span>); </span><br><span class="line">       <span class="keyword">if</span> (host == <span class="literal">null</span>) &#123; </span><br><span class="line">           getHost().addChild(ctx); </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">           host.addChild(ctx); </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> ctx; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Tomcat 的启动逻辑是基于观察者模式设计的，所有的容器都会继承 Lifecycle 接口，它管理者容器的整个生命周期，所有容器的的修改和状态的改变都会由它去通知已经注册的观察者<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/index.html" target="_blank" rel="noopener">原文链接</a></p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2></li><li><p>servlet容器负责加载和实例化Servlet，在容器启动时根据设置决定是在启动时初始化（loadOnStartup大于等于0，值越小优先级越高），还是延迟初始化直到第一次请求前</p></li><li>init()方法执行一次性的动作，可以通过ServletConfig配置对象，获取初始化参数，访问ServletContext上下文环境</li><li>配置：1.通过@WebServlet的initParams属性来指定。2.通过在web.xml文件中配置</li><li>Servlet默认是线程不安全的，单例多线程，一个容器中只有每个servlet一个实例。StandardWrapper负责Servlet的创建，其中SingleThreadModule模式下创建的实例数不能超过20个，也就是同时只能支持20个线程访问这个Serlvet。</li><li>Servlet多线程机制背后有一个线程池在支持，线程池在初始化初期就创建了一定数量的线程对象，通过提高对这些对象的利用率，避免高频率地创建对象，从而达到提高程序的效率的目的。<h2 id="Spring过滤器"><a href="#Spring过滤器" class="headerlink" title="Spring过滤器"></a>Spring过滤器</h2>用来实现一些特殊的功能。例如URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等。常见的有CharacterEncodingFilter、InvilidCharacterFilter(防止脚本攻击)等。<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3></li></ul><ol><li>编写Filter<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FilterTest</span> <span class="title">implements</span> <span class="title">Filter</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"----Filter销毁----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span>(<span class="params">ServletRequest request, ServletResponse response,FilterChain filterChain</span>) throws IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 对request、response进行一些预处理</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"----调用service之前执行一段代码----"</span>);</span><br><span class="line">        filterChain.doFilter(request, response); <span class="comment">// 执行目标资源，放行</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"----调用service之后执行一段代码----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span>(<span class="params">FilterConfig arg0</span>) throws ServletException </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"----Filter初始化----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>FilterConfig(init()方法的入参)获取配置的初始化参数</p> <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">String</span> getFilterName()：得到<span class="built_in">filter</span>的名称。</span><br><span class="line">　　<span class="keyword">String</span> getInitParameter(<span class="keyword">String</span> name)： 返回在部署描述中指定名称的初始化参数的值。如果不存在返回<span class="keyword">null</span>.</span><br><span class="line">　　Enumeration getInitParameterNames()：返回过滤器的所有初始化参数的名字的枚举集合。</span><br><span class="line">　　<span class="keyword">public</span> ServletContext getServletContext()：返回Servlet上下文对象的引用。</span><br></pre></td></tr></table></figure></li><li><p>FilterChain<br>web服务器将Filter组合起来形成为一个Filter链。根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。</p></li></ul><ol start="2"><li>注册<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">&lt;!--配置过滤器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.freaxjj.filter.FilterTest<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">      [<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>配置FilterTest过滤器的初始化参数<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>like<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>]</span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--映射过滤器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">      [<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>、<span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>]</span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><servlet-name>指定过滤器所拦截的Servlet名称。</servlet-name></li><li><dispatcher>指定过滤器所拦截的资源被 Servlet 容器调用的方式。默认子元素REQUEST。用户可以设置多个子元素用来指定 Filter 对资源的多种调用方式进行拦截<ul><li>REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。</li><li>INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。</li><li>FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li><li>ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class SelfDefineInvalidCharacterFilter implements Filter&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> destroy() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="keyword">String</span> parameterName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">String</span> parameterValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 获取请求的参数</span></span><br><span class="line">        @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">        Enumeration&lt;<span class="keyword">String</span>&gt; allParameter = request.getParameterNames();</span><br><span class="line">        <span class="keyword">while</span>(allParameter.hasMoreElements())&#123;</span><br><span class="line">            parameterName = allParameter.nextElement();</span><br><span class="line">            parameterValue = request.getParameter(parameterName);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != parameterValue)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">str</span> : invalidCharacter)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.containsIgnoreCase(parameterValue, <span class="built_in">str</span>))&#123;</span><br><span class="line">                        request.setAttribute(<span class="string">"errorMessage"</span>, <span class="string">"非法字符："</span> + <span class="built_in">str</span>);</span><br><span class="line">                        RequestDispatcher requestDispatcher = request.getRequestDispatcher(<span class="string">"/error.jsp"</span>);</span><br><span class="line">                        requestDispatcher.forward(request, response);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response); <span class="comment">// 执行目标资源，放行</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> init(FilterConfig filterConfig) <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要过滤的非法字符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span>[] invalidCharacter = <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;</span><br><span class="line">        <span class="string">"script"</span>,<span class="string">"select"</span>,<span class="string">"insert"</span>,<span class="string">"document"</span>,<span class="string">"window"</span>,<span class="string">"function"</span>,</span><br><span class="line">        <span class="string">"delete"</span>,<span class="string">"update"</span>,<span class="string">"prompt"</span>,<span class="string">"alert"</span>,<span class="string">"create"</span>,<span class="string">"alter"</span>,</span><br><span class="line">        <span class="string">"drop"</span>,<span class="string">"iframe"</span>,<span class="string">"link"</span>,<span class="string">"where"</span>,<span class="string">"replace"</span>,<span class="string">"function"</span>,<span class="string">"onabort"</span>,</span><br><span class="line">        <span class="string">"onactivate"</span>,<span class="string">"onafterprint"</span>,<span class="string">"onafterupdate"</span>,<span class="string">"onbeforeactivate"</span>,</span><br><span class="line">        <span class="string">"onbeforecopy"</span>,<span class="string">"onbeforecut"</span>,<span class="string">"onbeforedeactivateonfocus"</span>,</span><br><span class="line">        <span class="string">"onkeydown"</span>,<span class="string">"onkeypress"</span>,<span class="string">"onkeyup"</span>,<span class="string">"onload"</span>,</span><br><span class="line">        <span class="string">"expression"</span>,<span class="string">"applet"</span>,<span class="string">"layer"</span>,<span class="string">"ilayeditfocus"</span>,<span class="string">"onbeforepaste"</span>,</span><br><span class="line">        <span class="string">"onbeforeprint"</span>,<span class="string">"onbeforeunload"</span>,<span class="string">"onbeforeupdate"</span>,</span><br><span class="line">        <span class="string">"onblur"</span>,<span class="string">"onbounce"</span>,<span class="string">"oncellchange"</span>,<span class="string">"oncontextmenu"</span>,</span><br><span class="line">        <span class="string">"oncontrolselect"</span>,<span class="string">"oncopy"</span>,<span class="string">"oncut"</span>,<span class="string">"ondataavailable"</span>,</span><br><span class="line">        <span class="string">"ondatasetchanged"</span>,<span class="string">"ondatasetcomplete"</span>,<span class="string">"ondeactivate"</span>,</span><br><span class="line">        <span class="string">"ondrag"</span>,<span class="string">"ondrop"</span>,<span class="string">"onerror"</span>,<span class="string">"onfilterchange"</span>,<span class="string">"onfinish"</span>,<span class="string">"onhelp"</span>,</span><br><span class="line">        <span class="string">"onlayoutcomplete"</span>,<span class="string">"onlosecapture"</span>,<span class="string">"onmouse"</span>,<span class="string">"ote"</span>,</span><br><span class="line">        <span class="string">"onpropertychange"</span>,<span class="string">"onreadystatechange"</span>,<span class="string">"onreset"</span>,<span class="string">"onresize"</span>,</span><br><span class="line">        <span class="string">"onresizeend"</span>,<span class="string">"onresizestart"</span>,<span class="string">"onrow"</span>,<span class="string">"onscroll"</span>,</span><br><span class="line">        <span class="string">"onselect"</span>,<span class="string">"onstaronsubmit"</span>,<span class="string">"onunload"</span>,<span class="string">"IMgsrc"</span>,<span class="string">"infarction"</span></span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></dispatcher></li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Filter的创建和销毁由web服务器负责。 web应用程序启动时，web服务器将创建Filter的实例对象，并调用其init方法。filter对象只会创建一次。init方法和destroy方法在Filter的生命周期中仅执行一次。在destroy方法中，可以释放过滤器使用的资源。</p><p><a href="https://blog.csdn.net/reggergdsg/article/details/52821502" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Servlet容器与Tomcat&quot;&gt;&lt;a href=&quot;#Servlet容器与Tomcat&quot; class=&quot;headerlink&quot; title=&quot;Servlet容器与Tomcat&quot;&gt;&lt;/a&gt;Servlet容器与Tomcat&lt;/h2&gt;&lt;p&gt;Tomcat 的容器等级中，
      
    
    </summary>
    
      <category term="Spring" scheme="http://gitsarp.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://gitsarp.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring注解</title>
    <link href="http://gitsarp.github.io/Spring/Spring%E6%B3%A8%E8%A7%A3/"/>
    <id>http://gitsarp.github.io/Spring/Spring注解/</id>
    <published>2018-07-09T12:14:22.000Z</published>
    <updated>2018-07-11T14:42:03.547Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://wizardforcel.gitbooks.io/spring-doc-3x/" target="_blank" rel="noopener">spring中文文档</a>  感谢！</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="获取容器-上下文"><a href="#获取容器-上下文" class="headerlink" title="获取容器(上下文)"></a>获取容器(上下文)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    ApplicationContext ctx</span><br><span class="line">        = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig. <span class="class"><span class="keyword">class</span>)</span>; </span><br><span class="line">    MyService myService = ctx.getBean(MyService.class); </span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><ul><li><p><strong>@Scope</strong>注解定义该bean的作用域范围，注解方式如@scope(“prototype”),配置方式<bean scope="xxx" name="...">.</bean></p><ul><li>singleton,容器内只有一个实例，或@Singleton</li><li>prototype,原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</li><li><p>request,每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.request.RequestContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>session，配置同上，每次HTTP Session都会产生一个新的bean，同时该bean仅在当前HTTP session内有效</p></li><li>global session</li></ul></li><li>Bean注解主要用于方法上，有点类似于工厂方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和下面的配置类似<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myService"</span> <span class="attr">class</span>=<span class="string">"com.acme.services.MyServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h5 id="AutoWired和-Resource-J2EE注解"><a href="#AutoWired和-Resource-J2EE注解" class="headerlink" title="@AutoWired和@Resource(J2EE注解)"></a>@AutoWired和@Resource(J2EE注解)</h5><ul><li>@Autowired注解默认按照类型装配，如果容器中包含多个同一类型的Bean，那么启动容器时会报找不到指定类型bean的异常，解决办法是结合@Qualified注解进行限定，指定注入的bean名称。</li><li>@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。<h3 id="控制器注解-Controller"><a href="#控制器注解-Controller" class="headerlink" title="控制器注解@Controller"></a>控制器注解@Controller</h3></li><li><p><strong>@RestController</strong>,@RestController注解相当于@ResponseBody ＋ @Controller</p><ul><li>如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。</li><li>如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。</li><li>如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。</li></ul></li><li><p>@ModelAttribute</p></li><li>@RequestMapping 既可以作用在<strong>类级别</strong>，也可以作用在方法级别。如果没有指定method，表示都可以接收。(还有变体@GetMapping和@PostMapping)</li><li><strong>@RequestParam</strong>用于方法入参，@RequestParam(value = “name”, required = false) String name,required默认为true，必传</li><li><strong>@PathVariable</strong>,绑定url到参数上，支持正则</li><li><p>方法增加入参ModelMap modelMap，spring会创建实例，modelMap.put()可以用来向页面返回数据</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@RequestMapping</span>(value=<span class="string">"/happy/&#123;dayid&#125;"</span>,method=RequestMethod.GET)</span><br><span class="line">public String findPet(<span class="variable">@PathVariable</span> String dayid, Model mode) &#123;</span><br><span class="line"><span class="comment">//使用@PathVariable注解绑定 &#123;dayid&#125; 到String dayid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@RequestBody是指方法参数应该被绑定到HTTP请求Body上。</p></li><li>@ResponseBody的作用是将返回类型直接输入到HTTP response body中，常用来输出JSON数据。</li></ul><h4 id="Component与-Configuration"><a href="#Component与-Configuration" class="headerlink" title="@Component与@Configuration"></a>@Component与@Configuration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleBean <span class="title">simpleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleBeanConsumer <span class="title">simpleBeanConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleBeanConsumer(simpleBean());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@Component则需要这样写，否则就将有两个SimpleBean实例</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SimpleBean simpleBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleBean <span class="title">simpleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleBeanConsumer <span class="title">simpleBeanConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleBeanConsumer(simpleBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><ul><li>@Valid (在Controller响应方法的form对应实体入参上加入@Valid注解，在form对应实体的字段上添加@NotNull等注解)<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Null</span> 限制只能为null </span><br><span class="line"><span class="variable">@NotNull</span> 限制必须不为null </span><br><span class="line"><span class="variable">@AssertFalse</span> 限制必须为false </span><br><span class="line"><span class="variable">@AssertTrue</span> 限制必须为true </span><br><span class="line"><span class="variable">@DecimalMax</span>(value) 限制必须为一个不大于指定值的数字 </span><br><span class="line"><span class="variable">@DecimalMin</span>(value) 限制必须为一个不小于指定值的数字 </span><br><span class="line"><span class="variable">@Digits</span>(integer,fraction) 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction </span><br><span class="line"><span class="variable">@Future</span> 限制必须是一个将来的日期 </span><br><span class="line"><span class="variable">@Max</span>(value) 限制必须为一个不大于指定值的数字 </span><br><span class="line"><span class="variable">@Min</span>(value) 限制必须为一个不小于指定值的数字 </span><br><span class="line"><span class="variable">@Pattern</span>(value) 限制必须符合指定的正则表达式 </span><br><span class="line"><span class="variable">@Size</span>(max,min) 限制字符长度必须在min到max之间 </span><br><span class="line"><span class="variable">@Past</span> 验证注解的元素值（日期类型）比当前时间早 </span><br><span class="line"><span class="variable">@NotEmpty</span> 验证注解的元素值不为null且不为空（字符串长度不为<span class="number">0</span>、集合大小不为<span class="number">0</span>） </span><br><span class="line"><span class="variable">@NotBlank</span> 验证注解的元素值不为空（不为null、去除首位空格后长度为<span class="number">0</span>），不同于<span class="variable">@NotEmpty</span>，<span class="variable">@NotBlank</span>只应用于字符串且在比较时会去除字符串的空格 </span><br><span class="line"><span class="variable">@Email</span> 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式</span><br></pre></td></tr></table></figure></li></ul><p>eg.<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ResponseBody</span></span><br><span class="line">   <span class="variable">@PostMapping</span>(value=<span class="string">"/add"</span>)</span><br><span class="line">   public String add(<span class="variable">@Valid</span> Student student,BindingResult bindingResult)&#123; </span><br><span class="line"><span class="selector-tag">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@Table</span>(name=<span class="string">"t_student"</span>)</span><br><span class="line">public class Student &#123;</span><br><span class="line">   <span class="variable">@Id</span></span><br><span class="line">   <span class="variable">@GeneratedValue</span></span><br><span class="line">   private Integer id;</span><br><span class="line"></span><br><span class="line">   <span class="variable">@NotEmpty</span>(message=<span class="string">"姓名不能为空！"</span>)</span><br><span class="line">   <span class="variable">@Column</span>(length=<span class="number">50</span>)</span><br><span class="line">   private String name;</span><br><span class="line"></span><br><span class="line">   <span class="variable">@NotNull</span>(message=<span class="string">"年龄不能为空！"</span>)</span><br><span class="line">   <span class="variable">@Min</span>(value=<span class="number">18</span>,message=<span class="string">"年龄必须大于18岁！"</span>)</span><br><span class="line">   <span class="variable">@Column</span>(length=<span class="number">50</span>)</span><br><span class="line">   private Integer age;</span><br></pre></td></tr></table></figure><h3 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h3><ul><li>@PostConstruct 和 @PreDestroy 方法 实现初始化和销毁bean之前进行的操作 </li><li>lombok注解：可以不用生成get、set和构造方法，idea中安装lombok-plugin插件，另外勾选enable annotation processing<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Getter</span></span><br><span class="line"><span class="variable">@Setter</span></span><br><span class="line"><span class="variable">@NoArgsConstructor</span></span><br><span class="line"><span class="variable">@AllArgsConstructor</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li><p>开启事务注解&lt;tx:annotation-driven transaction-manager=”transactionManager” /&gt;,用@Transactional</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除失败后回滚</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompanyServiceImpl</span> <span class="keyword">implements</span> <span class="title">CompanyService</span> &#123;</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> CompanyDAO companyDAO;</span><br><span class="line">  <span class="comment">//设置传播、只读属性和回滚策略，回滚可定义其他异常，isolation定义隔离级别，timeout设置超时时间(s)</span></span><br><span class="line">  <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED, readOnly = <span class="literal">false</span>, rollbackFor = Exception.<span class="keyword">class</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> deleteByName(String name) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = companyDAO.deleteByName(name);</span><br><span class="line">    <span class="keyword">return</span> company;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>传播级别</p><p>| 事务传播行为类型          | 说明                                                         |<br>| ————————- | ———————————————————— |<br>| PROPAGATION_REQUIRED      | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 |<br>| PROPAGATION_SUPPORTS      | 支持当前事务，如果当前没有事务，就以非事务方式执行。         |<br>| PROPAGATION_MANDATORY     | 使用当前的事务，如果当前没有事务，就抛出异常。               |<br>| PROPAGATION_REQUIRES_NEW  | 新建事务，如果当前存在事务，把当前事务挂起。                 |<br>| PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。   |<br>| PROPAGATION_NEVER         | 以非事务方式执行，如果当前存在事务，则抛出异常               |<br>| PROPAGATION_NESTED        | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类 似的操作 |</p><p><img src="/Users/freaxjj/Downloads/transaction-propagation.png" alt="transaction-propagation"></p></li><li><p>隔离级别</p><p>| 类型                | 说明                                               |<br>| ——————- | ————————————————– |<br>| DEFAULT             | 采用数据库默认隔离级别                             |<br>| READ_UNCOMMITTED    | 读未提交的数据（会出现脏读取）                     |<br>| READ_COMMITTED      | 读已提交的数据（会出现幻读，即前后两次读的不一样） |<br>| REPEATABLE_READ     | 可重复读，会出现幻读                               |<br>| SERIALIZABLE 串行化 | （对资源消耗较大，一般不使用）                     |</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://wizardforcel.gitbooks.io/spring-doc-3x/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring中文文档&lt;/a&gt;  感谢！&lt;/p&gt;
&lt;h2 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解
      
    
    </summary>
    
      <category term="Spring" scheme="http://gitsarp.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://gitsarp.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://gitsarp.github.io/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://gitsarp.github.io/Java/多线程/</id>
    <published>2018-07-03T13:25:48.000Z</published>
    <updated>2018-07-21T11:10:31.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="https://upload-images.jianshu.io/upload_images/1689841-383f7101e6588094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="wait-和sleep"><a href="#wait-和sleep" class="headerlink" title="wait()和sleep()"></a>wait()和sleep()</h4><p>最大区别，<strong>wait()会释放锁，在被唤醒后再申请锁，而sleep若是在synchronized中，不会释放锁</strong></p><ul><li>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;</li><li><strong>sleep()是Thread类的Static(静态)的方法</strong>；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。</li><li>在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 </li></ul><ul><li><strong>wait()方法是Object类里的方法</strong>；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；</li><li>wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。</li><li><strong>wiat()必须放在synchronized中</strong>，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。</li></ul><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>使当前线程阻塞，等调用join的线程执行完后才能执行。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="built_in">join</span>(<span class="keyword">long</span> <span class="built_in">millis</span>)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="comment">//循环判断子线程是否存活，存活则一直等待</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = <span class="built_in">millis</span> - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>源码可以看出，主线程会循环判断子线程是否存活，存活则一直等待。这里的wait()是当前运行的线程，即主线程。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li>继承自Thread类(不能线程共享)</li><li>实现Runnable接口(<strong>无返回值</strong>)，用线程池的execute或submit提交</li><li>实现Callable接口(<strong>有返回值</strong>,可能抛出异常)，用线程池的submit提交，常用Future获取异步结果<h4 id="Runnable和Thread的区别"><a href="#Runnable和Thread的区别" class="headerlink" title="Runnable和Thread的区别"></a>Runnable和Thread的区别</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> Runnable是接口，定义了一个抽象的run()方法。这个方法会在线程执行时被调用。</span></span><br><span class="line"><span class="ruby">- Thread是类，实现了Runnable接口。类只能单继承，如果要继承其他类就需要自己实现Runnable接口。</span></span><br><span class="line"><span class="ruby">- 启动线程必须要通过start()方法（调用的native非java代码）,因此如果实现了Runable接口的可以构造Thread，而不能通过run()，否则只是调用了一个普通方法而已。</span></span><br><span class="line"><span class="ruby">- 如果用一个Runnable对象构造了多个线程，多个线程都start()起来,Runnable对象的属性都是共享的，相当于多个线程共同做一件事。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Callable接口和Future接口"><a href="#Callable接口和Future接口" class="headerlink" title="Callable接口和Future接口"></a>Callable接口和Future接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;<span class="comment">//返回值就是传入的泛型参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;<span class="comment">//参数表示是否取消正在运行的线程，返回值表示是否取消成功；如果线程还没有执行，总是返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg.<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Task</span> implements <span class="type">Callable</span>&lt;<span class="type">Integer</span>&gt;<span class="meta">&#123;...&#125;</span></span><br><span class="line">...</span><br><span class="line"><span class="type">Future</span>&lt;<span class="type">Integer</span>&gt; <span class="literal">result</span> = executor.submit(task);</span><br><span class="line"><span class="literal">result</span>.get()</span><br></pre></td></tr></table></figure></p><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>实现RunableFuture接口(顾名思义，既可以作为线程运行又可以获取结果)<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Task</span> implements <span class="type">Callable</span>&lt;<span class="type">Integer</span>&gt;<span class="meta">&#123;...&#125;</span></span><br><span class="line">...</span><br><span class="line"><span class="type">FutureTask</span>&lt;<span class="type">Integer</span>&gt; futureTask = new <span class="type">FutureTask</span>&lt;<span class="type">Integer</span>&gt;(task);</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">futureTask.get();</span><br></pre></td></tr></table></figure></p><h4 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h4><p>Future模式是多线程开发中非常常见的一种设计模式。它的核心思想是<strong>异步调用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回客户端的立即凭据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    Object data;<span class="comment">//处理结果</span></span><br><span class="line">    <span class="keyword">boolean</span> isReady;<span class="comment">//是否处理完毕标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//由处理线程处理完写入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data=data;</span><br><span class="line">        isReady=<span class="keyword">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由客户端通过凭据获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isReady)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> FutureData&lt;String&gt; returnFirst=<span class="keyword">new</span> FutureData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FutureData&lt;String&gt; <span class="title">handleReq</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程处理请求，就返回凭据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">                returnFirst.setData(<span class="string">"绝密文件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnFirst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">        Server server=<span class="keyword">new</span> Server();</span><br><span class="line">        FutureData&lt;String&gt; returnData=server.handleReq();</span><br><span class="line">        String doElse=<span class="string">" "</span>;<span class="comment">//做其他的事情</span></span><br><span class="line">        System.out.println(returnData.getData());</span><br></pre></td></tr></table></figure><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>优点：</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>线程池创建线程时，会将线程封装成<strong>工作线程</strong>Worker，Worker在执行完任务后，还会无限循环获取工作队列里的任务来执行。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。</li></ul><p><img src="https://res.infoq.com/articles/java-threadPool/zh/resources/threadpool.jpg" alt="策略"> </p><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ol><li>Executors的静态方法，返回ExecutorService实例;</li></ol><ul><li>newCachedThreadPool():线程数无限制;有空闲线程则复用空闲线程，若无空闲线程则新建线程;一定程序减少频繁创建/销毁线程，减少系统开销.</li><li>newFixedThreadPool():可控制线程最大并发数（同时执行的线程数）;超出的线程会在队列中等待</li><li>newScheduledThreadPool():支持定时及周期性任务执行。</li><li>newSingleThreadExecutor():有且仅有一个工作线程执行任务;所有任务按照指定顺序执行，即遵循队列的入队出队规则</li></ul><ol start="2"><li>new <strong>ThreadPoolExecutor</strong>(xxxx)，返回ThreadPoolExecutor实例(继承自AbstractExecutorService);<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">ThreadPoolExecutor</span>(<span class="built_in">int</span> corePoolSize,<span class="built_in">int</span> maximumPoolSize,long keepAliveTime,<span class="type">TimeUnit</span> unit,<span class="type">BlockingQueue</span>&lt;<span class="type">Runnable</span>&gt; workQueue,<span class="type">ThreadFactory</span> threadFactory,<span class="type">RejectedExecutionHandler</span> handler) <span class="meta">&#123;...&#125;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>corePoolSize和maximumPoolSize定义了进入队列和执行饱和策略的线程数阕值</li><li><strong>keepAliveTime</strong>线程池的工作线程空闲后，保持存活的时间。<strong>所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</strong></li><li>ThreadFactory：用于设置创建线程的工厂，<strong>可以通过线程工厂给每个创建出来的线程设置更有意义的名字，便于排查问题</strong>。</li><li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。<br>AbortPolicy（默认）：直接抛出异常。<br>CallerRunsPolicy：只用调用者所在线程来运行任务。<br>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。<br>DiscardPolicy：不处理，丢弃掉。<br>也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</li></ul><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ul><li>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</li><li>任务的优先级：高，中和低。</li><li>任务的执行时间：长，中和短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li></ul><p>任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p><p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p><p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p><p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。<br>(节选自<a href="http://www.infoq.com/cn/articles/java-threadPool" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/java-threadPool</a>)</p><h5 id="启动-提交"><a href="#启动-提交" class="headerlink" title="启动/提交"></a>启动/提交</h5><ul><li>execute(Runnable one) ,无返回值</li><li>submit(Runnable or Callable<t>),有返回值<br>get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">Object</span>&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="built_in">Object</span> s = future.<span class="keyword">get</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 处理中断异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></li></ul><h5 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h5><ul><li>调用线程池的shutdown或shutdownNow方法</li><li>原理都是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以<strong>无法响应中断的任务可能永远无法终止</strong>。</li><li>shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</li><li>调用了两者中任何一个关闭方法，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法才会返回true。</li><li><strong>通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow</strong>。</li></ul><h5 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h5><ol><li>线程池参数<br>taskCount：线程池需要执行的任务数量。<br>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。<br>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。<br>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减 getActiveCount：获取活动的线程数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService;</span><br><span class="line">    <span class="keyword">boolean</span> run;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MonitorThread</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executorService = executorService;</span><br><span class="line">        <span class="keyword">this</span>.run=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.run=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor=(ThreadPoolExecutor)executorService;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    String.format(<span class="string">"[monitor] [%d/%d] Active: %d, Completed: %d, Task: %d, isShutdown: %s, isTerminated: %s"</span>,</span><br><span class="line">                            executor.getPoolSize(),<span class="comment">//当前线程数量</span></span><br><span class="line">                            executor.getCorePoolSize(),<span class="comment">//基本线程数量</span></span><br><span class="line">                            executor.getActiveCount(),<span class="comment">//活动线程数</span></span><br><span class="line">                            executor.getCompletedTaskCount(),<span class="comment">//已完成任务数</span></span><br><span class="line">                            executor.getTaskCount(),<span class="comment">//需要执行的任务数</span></span><br><span class="line">                            executor.isShutdown(),<span class="comment">//是否已调用关闭方法</span></span><br><span class="line">                            executor.isTerminated()));<span class="comment">//是否已关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>*<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现方法<br>通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。</li></ol><h3 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h3><p>同步是一种高开销的操作，因此应该尽量减少同步的内容。<br><strong>临界区（critical section）</strong>：不管是同步代码块还是同步方法，每次只有一个线程可以进入，如果其他线程试图进入（不管是同一同步块还是不同的同步块），JVM会将它们挂起（放入到等锁池中）。</p><ol><li>synchronized</li><li>volatile<br>用在<strong>变量</strong>上，不能用在final类型的变量，变量的值在使用之前总会从主内存中再读取出来。对变量值的修改总会在完成之后写回到主内存中。保证数据可见性，不提供原子操作。</li><li>可重入锁ReentrantLock</li><li><p>使用局部变量 ThreadLocal，每个线程都有自己的副本</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new ThreadLocal(T) : 创建一个线程本地变量 </span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">()</span></span> : 返回此线程局部变量的当前线程副本中的值 </span><br><span class="line"><span class="function"><span class="title">initialValue</span><span class="params">()</span></span> : 返回此线程局部变量的当前线程的<span class="string">"初始值"</span> </span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(T value)</span></span> : 将此线程局部变量的当前线程副本中的值设置为value</span><br></pre></td></tr></table></figure></li><li><p>阻塞队列LinkedBlockingQueue，公用一个队列</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">LinkedBlockingQueue</span><span class="params">()</span></span> : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue </span><br><span class="line"><span class="function"><span class="title">put</span><span class="params">(E e)</span></span> : 在队尾添加一个元素，如果队列满则阻塞 </span><br><span class="line"><span class="function"><span class="title">size</span><span class="params">()</span></span> : 返回队列中的元素个数 </span><br><span class="line"><span class="function"><span class="title">take</span><span class="params">()</span></span> : 移除并返回队头元素，如果队列空则阻塞</span><br></pre></td></tr></table></figure></li><li><p>使用原子型变量，如AtomicInteger(util.concurrent.atomic)</p></li></ol><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul><li>synchronized可以用在<strong>方法或者代码块</strong>(颗粒更细一点)上<br>如果是synchronized(this){}，那么其他线程执行到同个对象的这段代码，必须要等持有对象锁的线程执行完才有机会；如果要锁住代码要通过synchronized(类名.class){}，这样如果就算是不同对象执行到这边也是要等待锁的</li><li>只能锁定对象，<strong>不能锁定基本数据类型</strong></li><li><strong>被锁定的对象数组中的单个对象不会被锁定</strong></li><li><strong>静态同步方法会锁定它的Class对象</strong></li><li>内部类的同步是独立于外部类的</li><li>synchronized修饰符并不是方法签名的组成部分，所以<strong>不能出现在接口的方法声明中</strong></li><li><strong>线程要么得到锁，要么阻塞，没有其他的可能性</strong></li><li>synchronized实现的锁是可重入的锁。</li></ul><h4 id="可重入锁ReentrantLock"><a href="#可重入锁ReentrantLock" class="headerlink" title="可重入锁ReentrantLock"></a>可重入锁ReentrantLock</h4><p>是可重入、互斥、实现了Lock接口的锁<br>常用方法</p><ul><li>ReentrantLock() : 创建一个ReentrantLock实例 </li><li>lock() : 获得锁 </li><li>unlock() : 释放锁<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Bank</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> account = <span class="number">100</span>;</span><br><span class="line">      <span class="comment">//创建锁</span></span><br><span class="line">      <span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> account;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span>(<span class="params"><span class="keyword">int</span> money</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">lock</span>.<span class="keyword">lock</span>();<span class="comment">//加锁</span></span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">              account += money;</span><br><span class="line">          &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">              <span class="keyword">lock</span>.unlock();<span class="comment">//解锁</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  ｝</span><br></pre></td></tr></table></figure></li></ul><h3 id="并发集合类"><a href="#并发集合类" class="headerlink" title="并发集合类"></a>并发集合类</h3><p>Java 5以后出现的并发集合类就是专门针对普通集合出现不能并发和不能在迭代过程中修改数据等问题而出现的。<br>主要有：</p><ul><li><strong>ConcurrentHashMap</strong>（替代hashtable）;        </li><li>ConcurrentSkipListMap;          </li><li>ConCurrentSkipListSet;         </li><li><strong>CopyOnWriteArrayList</strong><br>（是ArrayList 的一个线程安全的变形，其中所有可变操作（添加、设置，等等）都是通过对基础数组进行一次新的复制来实现的。这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效；自创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。不支持迭代器上更改元素的操作（移除、设置和添加）。）;</li><li>CopyOnWriteArraySet;        </li><li>ConcurrentLinkedQueue</li><li>（此队列按照 FIFO原则对元素进行排序，队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。不允许 null 元素。 ）</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>数据副本是避免共享数据的好方法，复制出来的对象只是以只读的方式对待(写时复制，如CopyOnWriteArrayList)</li><li><strong>Servlet</strong>就是以单实例多线程的方式工作，和每个请求相关的数据都是通过Servlet子类的service方法（或者是doGet或doPost方法）的参数传入的。只要Servlet中的代码只使用局部变量，Servlet就不会导致同步问题。<strong>Spring MVC</strong>的控制器也是这么做的，从请求中获得的对象都是以方法的参数传入而不是作为类的成员，很明显Struts 2的做法就正好相反，因此Struts 2中作为控制器的Action类都是每个请求对应一个实例</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程状态&quot;&gt;&lt;a href=&quot;#线程状态&quot; class=&quot;headerlink&quot; title=&quot;线程状态&quot;&gt;&lt;/a&gt;线程状态&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16898
      
    
    </summary>
    
      <category term="Java" scheme="http://gitsarp.github.io/categories/Java/"/>
    
    
      <category term="Java多线程" scheme="http://gitsarp.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://gitsarp.github.io/Java/JVM/"/>
    <id>http://gitsarp.github.io/Java/JVM/</id>
    <published>2018-07-01T14:03:14.000Z</published>
    <updated>2018-07-03T14:35:36.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p> 体系：</p><ul><li>类的加载机制</li><li>jvm内存结构</li><li>GC算法 垃圾回收</li><li>GC分析 命令调优</li></ul><blockquote><p>加载</p></blockquote><p>类的生命周期：</p><ul><li>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li><li>连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用</li><li>初始化，为类的静态变量赋予正确的初始值</li><li>使用，new出对象程序中使用</li><li>卸载，执行垃圾回收</li></ul><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的<strong>方法区</strong>内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。</p><ul><li>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库</li><li>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器</li></ul><blockquote><p>内存</p></blockquote><ul><li><p>Java堆（Heap、GC堆）,是Java虚拟机所管理的<strong>内存中最大</strong>的一块。Java堆是被所有线程<strong>共享</strong>的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。<strong><em>堆由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配</em></strong></p><p>  初级回收将年轻代分为三个区域, 一个新生代 , 2个大小相同的复活代, 应用程序只能使用一个新生代和一个复活代, 当发生初级垃圾回收的时候,gc挂起程序, 然后将新生代和复活代中的存活对象复制到另外一个非活动的复活代中,然后一次性清除新生代和复活代，将原来的非复活代标记成为活动复活代。将在指定次数回收后仍然存在的对象移动到老年代中，初级回收后，得到一个空的可用的新生代。(参考文章：[JVM内存：年轻代，老年代，永久代][<a href="https://blog.csdn.net/sted_zxz/article/details/72476673]" target="_blank" rel="noopener">https://blog.csdn.net/sted_zxz/article/details/72476673]</a>)</p></li><li><p>方法区（Method Area，永久代）,方法区与Java堆一样，是各个线程<strong>共享</strong>的内存区域，它用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p></li><li><p>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个<strong>栈帧（Stack Frame）</strong>用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p></li><li><p>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">控制参数</span><br><span class="line">-<span class="ruby">Xms设置堆的最小空间大小。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-Xmx设置堆的最大空间大小。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>NewSize设置新生代最小空间大小。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>MaxNewSize设置新生代最大空间大小。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>PermSize设置永久代最小空间大小。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>MaxPermSize设置永久代最大空间大小。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">-Xss设置每个线程的堆栈大小。</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">如果没有直接设置老年代的参数，老年代空间大小=堆空间大小-年轻代大空间大小</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>垃圾回收</p></blockquote><ol><li>判断对象是否存活一般有两种方式：</li></ol><ul><li>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</li><li>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</li></ul><ol start="2"><li>GC算法</li></ol><p>GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用<strong>分代收集算法</strong>。</p><p>PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数 </p><blockquote><p>调优</p></blockquote><p><strong>调优命令</strong></p><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</p><ul><li>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li><li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li><li>jmap，JVM Memory Map命令用于生成heap dump文件</li><li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li><li>jstack，用于生成java虚拟机当前时刻的线程快照。</li><li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</li></ul><p><strong>调优工具</strong></p><p>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。</p><ul><li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li><li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</li><li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li><li>GChisto，一款专业分析gc日志的工具</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h3&gt;&lt;p&gt; 体系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类的加载机制&lt;/li&gt;
&lt;li&gt;jvm内存结构&lt;/li&gt;
&lt;li&gt;GC算法 垃圾回收&lt;/li&gt;

      
    
    </summary>
    
      <category term="Java" scheme="http://gitsarp.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://gitsarp.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Sql 注入基础原理介绍</title>
    <link href="http://gitsarp.github.io/sql/sql%E6%B3%A8%E5%85%A5/"/>
    <id>http://gitsarp.github.io/sql/sql注入/</id>
    <published>2018-07-01T14:03:14.000Z</published>
    <updated>2018-07-11T14:39:59.105Z</updated>
    
    <content type="html"><![CDATA[<p>一、实验说明<br>1.1 实验内容<br>SQL注入攻击通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，本章课程通过 LAMP 搭建 Sql 注入环境，两个实验分别介绍 Sql 注入爆破数据库、Sql 注入绕过验证两个知识点。<br>1.2 实验知识点<br>Sql 注入漏洞的原理<br>Sql 注入点的判断方法<br>Sql 注入漏洞的分类</p><p>1.3 实验环境<br>python2.7<br>Xfce 终端<br>Firefox 浏览器</p><p>1.4 适合人群<br>本课程难度为简单，属于初级级别课程，适合具有一点 sql 语法基础的用户。<br>如果你没有 sql 的基础，建议你先阅读下述内容：<br><a href="https://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">Mysql 入门教程</a></p><p>或学习以下免费课程：<br><a href="https://www.shiyanlou.com/courses/9" target="_blank" rel="noopener">MySQL 基础课程</a></p><p>1.5 代码获取<br>你可以通过下面命令将代码下载到实验楼环境中，作为参照对比进行学习。<br>$ wget <a href="http://labfile.oss.aliyuncs.com/courses/876/dvwa.tar.gz$" target="_blank" rel="noopener">http://labfile.oss.aliyuncs.com/courses/876/dvwa.tar.gz$</a> wget <a href="http://labfile.oss.aliyuncs.com/courses/876/sql2.tar.gz" target="_blank" rel="noopener">http://labfile.oss.aliyuncs.com/courses/876/sql2.tar.gz</a></p><p>二、实验原理<br>Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。<br>本课程将带你从介绍 Web 应用运行原理开始，一步一步理解 Sql 注入的由来、原理和攻击方式。<br>三、Web 程序三层架构<br><strong>三层架构</strong>(3-tier architecture<br>) 通常意义上就是将整个业务应用划分为：<br>界面层（User Interface layer）</p><p>业务逻辑层（Business Logic Layer）</p><p>数据访问层（Data access layer）。</p><p>区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构被应用于众多类型的软件开发。<br>由数据库驱动的Web应用程序依从三层架构的思想也分为了三层：<br>表示层。</p><p>业务逻辑层（又称领域层）</p><p>数据访问层（又称存储层）</p><p>拓扑结构如下图所示<br><img src="http://upload-images.jianshu.io/upload_images/3341325-5d580f47215d6a75?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此处输入图片的描述"><br>在上图中，用户访问实验楼主页进行了如下过程：<br>在 Web 浏览器中输入 <a href="http://www.shiyanlou.com" target="_blank" rel="noopener">www.shiyanlou.com</a><br> 连接到实验楼服务器。</p><p>业务逻辑层的 Web 服务器从本地存储中加载 index.php<br> 脚本并解析。</p><p>脚本连接位于数据访问层的 DBMS<br>（数据库管理系统），并执行 Sql<br> 语句。</p><p>数据访问层的数据库管理系统返回 Sql<br> 语句执行结果给 Web 服务器。</p><p>业务逻辑层的 Web 服务器将 Web 页面封装成 HTML 格式发送给表示层的 Web 浏览器。</p><p>表示层的 Web 浏览器解析 HTML 文件，将内容展示给用户。</p><p>在三层架构中，所有通信都必须要经过中间层，简单地说，三层架构是一种<strong>线性关系</strong>。<br>四、Sql 注入漏洞<br>4.1 Sql 注入产生原因及威胁：<br>刚刚讲过当我们访问动态网页时, Web 服务器会向数据访问层发起 Sql 查询请求，如果权限验证通过就会执行 Sql 语句。<br>这种网站内部直接发送的Sql请求一般不会有危险，但实际情况是很多时候需要<strong>结合</strong>用户的输入数据动态构造 Sql 语句，如果用户输入的数据被构造成恶意 Sql 代码，Web 应用又未对动态构造的 Sql 语句使用的参数进行审查，则会带来意想不到的危险。<br>Sql 注入带来的威胁主要有如下几点<br>猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。<br>绕过认证，列如绕过验证登录网站后台。<br>注入可以借助数据库的存储过程进行提权等操作</p><p>4.2 Sql 注入示例一.猜解数据库<br>接下来我们通过一个实例，让你更加清楚的理解 <strong>Sql 注入猜解数据库</strong>是如何发生的。<br>如下图所示，先下载文件并解压运行：<br>shiyanlou:~/ $ wget <a href="http://labfile.oss.aliyuncs.com/courses/876/dvwa.tar.gzshiyanlou:~/" target="_blank" rel="noopener">http://labfile.oss.aliyuncs.com/courses/876/dvwa.tar.gzshiyanlou:~/</a> $ tar -zxvf dvwa.tar.gzshiyanlou:~/ $ cd dvwashiyanlou:~/ $ sudo apt-get updateshiyanlou:~/ $ ./deploy.sh</p><p>进入 Firefox 浏览器，输入网址 : localhost/dvwasql , 点击create/Reset Database<br>创建数据库：<br>[图片上传中。。。（2）]<br><img src="http://upload-images.jianshu.io/upload_images/3341325-8821ff02acd6c9d6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此处输入图片的描述"><br>进入登录界面，默认用户名为 admin<br> 密码为 password</p><p><img src="http://upload-images.jianshu.io/upload_images/3341325-7365f4a81aea09ae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此处输入图片的描述"><br>将 Security 级别调整为 low<br> (有兴趣的同学可以看看其他级别，这里只做入门讲解)<br><img src="http://upload-images.jianshu.io/upload_images/3341325-a5a66553e010a0b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此处输入图片的描述"><br>进入 SQL injection<br>页面开始注入：<br><img src="http://upload-images.jianshu.io/upload_images/3341325-9521f26625ce7ec7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此处输入图片的描述"><br>先输入 1 ，查看回显 (URL中ID=1，说明php页面通过get方法传递参数)：<br><img src="http://upload-images.jianshu.io/upload_images/3341325-290adb169a53a795?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此处输入图片的描述"><br>那实际上后台执行了什么样的Sql语句呢？点击 view source<br>查看源代码 ：<br><img src="http://upload-images.jianshu.io/upload_images/3341325-05191e835ff12eb5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此处输入图片的描述"><br>可以看到，实际执行的Sql语句是：<br>SELECT first_name, last_name FROM users WHERE user_id = ‘1’;</p><p>我们是通过控制参数Id的值来返回我们需要的信息。<br>如果我们不按常理出牌，比如在输入框中输入 1’ order by 1#</p><p>实际执行的Sql语句就会变成:<br>SELECT first_name, last_name FROM users WHERE user_id = ‘1’ order by 1#`;(按照Mysql语法，#后面会被注释掉，使用这种方法屏蔽掉后面的单引号，避免语法错误)</p><p>这条语句的意思是查询users表中user_id为1的数据并按第一字段排行。<br>输入 1’ order by 1#<br>和 1’ order by 2#<br>时都返回正常：<br><img src="http://upload-images.jianshu.io/upload_images/3341325-ecb1728c17473a60?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此处输入图片的描述"><br><img src="http://upload-images.jianshu.io/upload_images/3341325-498039aedd6efcf0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此处输入图片的描述"><br>当输入 1’ order by 3#<br>时，返回错误：<br>[图片上传中。。。（11）]<br><strong>由此可知，users表中只有两个字段，数据为两列。</strong><br>接下来我们使用 union select<br>联合查询继续获取信息。<br>union 运算符可以将两个或两个以上 select 语句的查询结果集合合并成一个结果集合显示，即执行联合查询。需要注意在使用 union 查询的时候需要和主查询的列数相同，而我们之前已经知道了主查询列数为 2，接下来就好办了。<br>输入1’ union select database(),user()#<br>进行查询 ：<br>database()将会返回当前网站所使用的数据库名字.<br>user()将会返回执行当前查询的用户名.</p><p>实际执行的Sql语句是 :<br>SELECT first_name, last_name FROM users WHERE user_id = ‘1’ union select database(),user()#`;</p><p>[图片上传中。。。（12）]<br>通过上图返回信息，我们成功获取到：<br>当前网站使用数据库为 dvwa .<br>当前执行查询用户名为 root@localhost .</p><p>同理我们再输入 1’ union select version(),@@version_compile_os#<br>进行查询：<br>version() 获取当前数据库版本.<br>@@version_compile_os 获取当前操作系统。</p><p>实际执行的Sql语句是:<br>SELECT first_name, last_name FROM users WHERE user_id = ‘1’ union select version(),@@version_compile_os#`;</p><p>[图片上传中。。。（13）]<br>通过上图返回信息，我们又成功获取到：<br>当前数据库版本为 : 5.6.31-0ubuntu0.15.10.1.<br>当前操作系统为 : debian-linux-gnu</p><p>接下来我们尝试获取 dvwa 数据库中的表名。<br>information_schema<br> 是 mysql 自带的一张表，这张数据表保存了 Mysql 服务器所有数据库的信息,如数据库名，数据库的表，表栏的数据类型与访问权限等。该数据库拥有一个名为 tables 的数据表，该表包含两个字段 table_name 和 table_schema，分别记录 DBMS 中的存储的表名和表名所在的数据库。<br>我们输入1’ union select table_name,table_schema from information_schema.tables where table_schema= ‘dvwa’#<br>进行查询：<br>实际执行的Sql语句是：<br>SELECT first_name, last_name FROM users WHERE user_id = ‘1’ union select table_name,table_schema from information_schema.tables where table_schema= ‘dvwa’#`;</p><p>[图片上传中。。。（14）]<br>通过上图返回信息，我们再获取到：<br>dvwa 数据库有两个数据表，分别是 guestbook 和 users .</p><p>有些同学肯定还不满足目前获取到的信息，那么我们接下来尝试获取重量级的用户名、密码。<br>由经验我们可以大胆猜测users表的字段为 user 和 password ，所以输入：1’ union select user,password from users#<br>进行查询：<br>实际执行的 Sql 语句是：<br>SELECT first_name, last_name FROM users WHERE user_id = ‘1’ union select user,password from users#`;</p><p>[图片上传中。。。（15）]<br>可以看到成功爆出用户名、密码，密码采用 md5 进行加密，可以到<a href="http://www.cmd5.com" target="_blank" rel="noopener">www.cmd5.com</a><br>进行解密。<br>直此，同学们应该已经对 Sql 注入有了一个大概得了解，也清楚了 Sql 注入的强大。<br>4.3 Sql 注入实例二.验证绕过<br>接下来我们再试试另一个利用 <strong>Sql 漏洞绕过登录验证</strong>的实验。<br>如下图所示，先下载文件并解压运行：<br>shiyanlou:~/ $ wget <a href="http://labfile.oss.aliyuncs.com/courses/876/sql2.tar.gzshiyanlou:~/" target="_blank" rel="noopener">http://labfile.oss.aliyuncs.com/courses/876/sql2.tar.gzshiyanlou:~/</a> $ tar -zxvf sql2.tar.gzshiyanlou:~/ $ cd sql2shiyanlou:~/ $ sudo apt-get update shiyanlou:~/ $ ./deploy.sh</p><p>进入 Firefox 浏览器，输入网址 : localhost/sql2 , 按照下图所示顺序，初始化数据：<br>[图片上传中。。。（16）]<br>[图片上传中。。。（17）]<br>[图片上传中。。。（18）]<br>[图片上传中。。。（19）]<br>准备工作完成之后，我们进入首页发现这是一个普通的登录页面，只要输入正确的用户名和密码就能登录成功。<br>我们先尝试随意输入用户名 123 和密码 123 登录：<br>[图片上传中。。。（20）]<br>从错误页面中我们无法获取到任何信息。<br>看看后台代码如何做验证的：<br>[图片上传中。。。（21）]<br>实际执行的操作时：<br>select * from users where username=’123’ and password=’123’</p><p>当查询到数据表中存在同时满足 username 和 password 字段时，会返回登录成功。<br>按照第一个实验的思路，我们尝试在用户名中输入 123’ or 1=1 #<br>, 密码同样输入 123’ or 1=1 #<br> ：<br>[图片上传中。。。（22）]<br>[图片上传中。。。（23）]<br>为什么能够成功登陆呢？因为实际执行的语句是：<br>select * from users where username=’123’ or 1=1 #’ and password=’123’ or 1=1 #’</p><p>按照 Mysql 语法，# 后面的内容会被忽略，所以以上语句等同于（实际上密码框里不输入任何东西也一样）：<br>select * from users where username=’123’ or 1=1</p><p>由于判断语句 or 1=1 恒成立，所以结果当然返回真，成功登录。<br>我们再尝试不使用 # 屏蔽单引号，采用手动闭合的方式：<br>我们尝试在用户名中输入 123’ or ‘1’=’1<br>, 密码同样输入 123’ or ‘1’=’1<br> （不能少了单引号，否则会有语法错误）：<br>[图片上传中。。。（24）]<br>[图片上传中。。。（25）]<br>实际执行的 Sql 语句是：<br>select * from users where username=’123’ or ‘1’=’1’ and password=’123’ or ‘1’=’1`</p><p>看到了吗？两个 or 语句使 and 前后两个判断永远恒等于真，所以能够成功登录。<br>还有很多其他 Mysql 语句可以巧妙的绕过验证，同学们可以发散自己的思维进行尝试。<br>五、判断 Sql 注入点<br>通常情况下，可能存在 Sql 注入漏洞的 Url 是类似这种形式 ：<a href="http://xxx.xxx.xxx/abcd.php?id=XX" target="_blank" rel="noopener">http://xxx.xxx.xxx/abcd.php?id=XX</a></p><p>对 Sql 注入的判断，主要有两个方面：<br>判断该带参数的 Url 是否存在 Sql 注入？<br>如果存在 Sql 注入，那么属于哪种 Sql 注入？</p><p>可能存在 Sql 注入攻击的 ASP/PHP/JSP 动态网页中，一个动态网页中可能只有一个参数，有时可能有多个参数。有时是整型参数，有时是字符串型参数，不能一概而论。总之只要是带有参数的 动态网页且此网页访问了数据库，那么就有可能存在 Sql 注入。如果程序员没有足够的安全意识，没有进行必要的字符过滤，存在SQL注入的可能性就非常大。<br>5.1 判断是否存在 Sql 注入漏洞<br>最为经典的<strong>单引号判断法</strong>：<br>在参数后面加上单引号,比如:<br><a href="http://xxx/abc.php?id=1&#39;" target="_blank" rel="noopener">http://xxx/abc.php?id=1&#39;</a></p><p>如果页面返回错误，则存在 Sql 注入。<br>原因是无论字符型还是整型都会因为单引号个数不匹配而报错。<br>（如果未报错，不代表不存在 Sql 注入，因为有可能页面对单引号做了过滤，这时可以使用判断语句进行注入，因为此为入门基础课程，就不做深入讲解了）<br>5.2 判断 Sql 注入漏洞的类型<br>通常 Sql 注入漏洞分为 2 种类型：<br>数字型<br>字符型</p><p>其实所有的类型都是根据数据库本身表的类型所产生的，在我们创建表的时候会发现其后总有个数据类型的限制，而不同的数据库又有不同的数据类型，但是无论怎么分<strong>常用</strong>的查询数据类型总是以数字与字符来区分的，所以就会产生注入点为何种类型。<br>[图片上传中。。。（26）]<br>5.2.1 数字型判断：<br>当输入的参 x 为整型时，通常 abc.php 中 Sql 语句类型大致如下：<br>select * from &lt;表名&gt; where id = x</p><p>这种类型可以使用经典的 and 1=1<br> 和 and 1=2<br> 来判断：<br>Url 地址中输入 <a href="http://xxx/abc.php?id=" target="_blank" rel="noopener">http://xxx/abc.php?id=</a> x and 1=1<br> 页面依旧运行正常，继续进行下一步。</p><p>Url 地址中继续输入 <a href="http://xxx/abc.php?id=" target="_blank" rel="noopener">http://xxx/abc.php?id=</a> x and 1=2<br> 页面运行错误，则说明此 Sql 注入为数字型注入。</p><p>原因如下：<br>当输入 and 1=1<br>时，后台执行 Sql 语句：<br>select * from &lt;表名&gt; where id = x and 1=1</p><p>没有语法错误且逻辑判断为正确，所以返回正常。<br>当输入 and 1=2<br>时，后台执行 Sql 语句：<br>select * from &lt;表名&gt; where id = x and 1=2</p><p>没有语法错误但是逻辑判断为假，所以返回错误。<br>我们再使用假设法：如果这是字符型注入的话，我们输入以上语句之后应该出现如下情况：<br>select <em> from &lt;表名&gt; where id = ‘x and 1=1’ select </em> from &lt;表名&gt; where id = ‘x and 1=2’</p><p>查询语句将 and 语句全部转换为了字符串，并没有进行 and 的逻辑判断，所以不会出现以上结果，故假设是不成立的。<br>5.2.2 字符型判断：<br>当输入的参 x 为字符型时，通常 abc.php 中 SQL 语句类型大致如下：<br>select * from &lt;表名&gt; where id = ‘x’</p><p>这种类型我们同样可以使用 and ‘1’=’1<br> 和 and ‘1’=’2<br>来判断：<br>Url 地址中输入 <a href="http://xxx/abc.php?id=" target="_blank" rel="noopener">http://xxx/abc.php?id=</a> x’ and ‘1’=’1<br> 页面运行正常，继续进行下一步。</p><p>Url 地址中继续输入 <a href="http://xxx/abc.php?id=" target="_blank" rel="noopener">http://xxx/abc.php?id=</a> x’ and ‘1’=’2<br> 页面运行错误，则说明此 Sql 注入为字符型注入。</p><p>原因如下：<br>当输入 and ‘1’=’1<br>时，后台执行 Sql 语句：<br>select * from &lt;表名&gt; where id = ‘x’ and ‘1’=’1’</p><p>语法正确，逻辑判断正确，所以返回正确。<br>当输入 and ‘1’=’2<br>时，后台执行 Sql 语句：<br>select * from &lt;表名&gt; where id = ‘x’ and ‘1’=’2’</p><p>语法正确，但逻辑判断错误，所以返回正确。同学们同样可以使用假设法来验证。<br>六、 总结<br>sql注入常用技术有段还包括：<br>采用非主流通道技术<br>避开输入过滤技术<br>使用特殊的字符<br>强制产生错误<br>使用条件语句<br>利用存储过程<br>推断技术<br>……..</p><p>内容转载自实验楼</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、实验说明&lt;br&gt;1.1 实验内容&lt;br&gt;SQL注入攻击通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，本章课程通过 LAMP 搭建 Sql 注入环境，两个实验分别介绍 Sql 注入爆破数据
      
    
    </summary>
    
      <category term="sql" scheme="http://gitsarp.github.io/categories/sql/"/>
    
    
      <category term="sql注入" scheme="http://gitsarp.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>java环境问题</title>
    <link href="http://gitsarp.github.io/Java/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    <id>http://gitsarp.github.io/Java/开发工具/</id>
    <published>2018-07-01T13:51:58.000Z</published>
    <updated>2018-07-11T14:40:23.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h4 id="快捷键-Mac"><a href="#快捷键-Mac" class="headerlink" title="快捷键(Mac)"></a>快捷键(Mac)</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入ps(<span class="meta">public</span> static的缩写)可以生成main方法和其他<span class="number">4</span>个方法</span><br><span class="line">ctrl+D复制当前行(有时没用？光标定位句首，ctrl+K，再粘贴)</span><br><span class="line"><span class="meta">option</span>+<span class="keyword">enter</span>引入包</span><br><span class="line">ctrl+J查看方法说明</span><br><span class="line">win+回退键    删除当前行</span><br><span class="line"><span class="meta">option</span>+<span class="keyword">enter</span>快速生成构造方法等</span><br><span class="line">ctrl+I实现父类接口</span><br><span class="line">ctrl +O重写父类方法</span><br></pre></td></tr></table></figure><h4 id="启动Tomcat报错"><a href="#启动Tomcat报错" class="headerlink" title="启动Tomcat报错"></a>启动Tomcat报错</h4><p>Error running Tomcat7.0.52: Address localhost:1099 is already in use 或者是 java.rmi.server.ExportException: Port already in use: 1099 ，表示1099端口被其他进程占用了。<br>解决方法：</p><ul><li>win+R，运行，输入cmd，进入命令提示符（管理员）</li><li>输入netstat -aon | findstr 1099，找到占用1099端口的进程ID：PID</li><li>输入taskkill -f -pid PID</li><li>重启Tomcat</li></ul><h4 id="idea设置UTF编码"><a href="#idea设置UTF编码" class="headerlink" title="idea设置UTF编码"></a>idea设置UTF编码</h4><ul><li>idea安装bin目录下，idea64.exe.vmoptions或者idea.exe.vmoptions（32位），添加-Dfile.encoding=UTF-8</li><li>setting中设置file Encoding全为utf-8</li><li>tomcat设置<br><img src="http://upload-images.jianshu.io/upload_images/3341325-67522ef2f87b9e21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/3341325-c2682d7997ca5f22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>最后pom.xml,由于idea中maven的配置优先 <plugins><br>    <plugin><br>      <groupid>org.apache.maven.plugins</groupid><br>      <artifactid>maven-surefire-plugin</artifactid><br>      <version>2.12.4</version><br>      <configuration><br>        <forkmode>once</forkmode><br>        <argline>-Dfile.encoding=UTF-8</argline><br>      </configuration><br>    </plugin><br>  </plugins></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;开发工具&quot;&gt;&lt;a href=&quot;#开发工具&quot; class=&quot;headerlink&quot; title=&quot;开发工具&quot;&gt;&lt;/a&gt;开发工具&lt;/h2&gt;&lt;h4 id=&quot;快捷键-Mac&quot;&gt;&lt;a href=&quot;#快捷键-Mac&quot; class=&quot;headerlink&quot; title=&quot;快捷键
      
    
    </summary>
    
      <category term="Java" scheme="http://gitsarp.github.io/categories/Java/"/>
    
    
      <category term="javaIDE" scheme="http://gitsarp.github.io/tags/javaIDE/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://gitsarp.github.io/Java/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://gitsarp.github.io/Java/Java基础/</id>
    <published>2018-07-01T13:31:48.000Z</published>
    <updated>2018-07-03T14:14:43.362Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><ol><li>基本数据类型</li></ol><table><thead><tr><th>Name</th><th style="text-align:center">字节数</th><th style="text-align:right">初始值 </th></tr></thead><tbody><tr><td>byte</td><td style="text-align:center">1</td><td style="text-align:right">0</td></tr><tr><td>char</td><td style="text-align:center">2</td><td style="text-align:right">空格 </td></tr><tr><td>short</td><td style="text-align:center">2</td><td style="text-align:right">0</td></tr><tr><td>int</td><td style="text-align:center">4</td><td style="text-align:right">0</td></tr><tr><td>float</td><td style="text-align:center">4</td><td style="text-align:right">0.0f</td></tr><tr><td>long</td><td style="text-align:center">8</td><td style="text-align:right">0L</td></tr><tr><td>double</td><td style="text-align:center">8</td><td style="text-align:right">0.0d</td></tr><tr><td>char</td><td style="text-align:center">2</td><td style="text-align:right">空格 </td></tr><tr><td>boolean</td><td style="text-align:center">不明确</td><td style="text-align:right">false</td></tr></tbody></table><ol start="2"><li>获得变量类型：<br>1.System.out.println(TypeToolsTest2.class.getDeclaredField(“ii”).getType()); //成员变量<br>2.System.out.println(Integer.class.isInstance(ii));<br>3.泛型T.getClass().getName();</li></ol><ol start="3"><li><p>Java 会对 -128~127 的整数进行缓存<br> 因此Integer a=128;Integer b=128;xx c=127;xx d=127<br> a!=b but c==d     (IntegerCache.class)<br> == 它比较的是对象的地址;equals 比较的是对象的内容</p></li><li><p>IO:<br> <code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));br.read();/br.readLine();</code><br> <img src="http://www.runoob.com/wp-content/uploads/2013/12/iostream2xx.png" alt="类图"></p></li><li><p>类的实例化顺序：父类static，子类static，父类普通代码，父类构造，子类普通，子类构造</p></li><li><p>强引用：用关键词new出来的对象，强引用锁指向的对象在任何时候都不会被回收 ，即使内存不足，抛出错误。</p></li><li><p>集合：根接口Collection，List（有序可重复）,Set（无序不重复）接口都继承他。Map是单独的。</p><p> LinkedList：底层用双链表实现:增加删除效率高<br> ArrayList：底层用数组实现:查找效率高<br> Vector：实现了一个动态数组。和ArrayList相似，但是有以下不同：vector是同步的； vector包含了许多传统方法，或者只是需要一个可以改变大小的数组的情况。</p><pre><code>Stack:先进后出</code></pre><p> HashSet:HashSet不存入重复元素的规则.使用hashcode和equals</p><pre><code>LinkedHashSet:是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法</code></pre><p> TreeSet:让存入的元素自定义比较规则;给TreeSet指定排序规则<br> 7.HashMap和HashSet的区别<br> 前者可以接受键和值为null，线程不安全，单线程效率高；后者线程安全，Java5后可以由CurrentHashMap替代。前者不能保证数据的顺序随着时间的推移不变。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java基础&quot;&gt;&lt;a href=&quot;#Java基础&quot; class=&quot;headerlink&quot; title=&quot;Java基础&quot;&gt;&lt;/a&gt;Java基础&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;基本数据类型&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://gitsarp.github.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://gitsarp.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于Linux</title>
    <link href="http://gitsarp.github.io/Linux/linux/"/>
    <id>http://gitsarp.github.io/Linux/linux/</id>
    <published>2018-07-01T13:31:48.000Z</published>
    <updated>2018-07-03T14:02:50.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能查看命令"><a href="#性能查看命令" class="headerlink" title="性能查看命令"></a>性能查看命令</h2><h4 id="java相关"><a href="#java相关" class="headerlink" title="java相关"></a>java相关</h4><p>ps -ef | grep java                 找所有有关“java”的进程<br>ps -efL | grep [PID] | wc -l         查看某个进程创建的线程数<br>jmap -histo [pid]                 按照对象内存大小排序 注意会导致full gc</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><ol><li><p>free</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free [<span class="string">－b　－k　－m</span>][<span class="symbol">－o</span>] [<span class="string">－s delay</span>][<span class="symbol">－t</span>] [－V]</span><br><span class="line">－b －k －m：分别以字节（KB、MB）为单位显示内存使用情况。</span><br><span class="line">－s delay：显示每隔多少秒数来显示一次内存使用情况。</span><br><span class="line">－t：显示内存总和列。 －o：不显示缓冲区调节列。</span><br><span class="line">和top命令相比，它的优点是使用简单，并且只占用很少的系统资源。</span><br></pre></td></tr></table></figure></li><li><p>vmstat</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vmstat <span class="number">3</span>(间隔时间) <span class="number">100</span>(监控次数)</span><br><span class="line">eg:</span><br><span class="line">[root@iZbp10fstdmbee21wif5ngZ <span class="number">2018-02-26</span>]# vmstat <span class="number">3</span> <span class="number">100</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line">r b swpd free buff cache si so bi bo in cs us sy id wa st</span><br><span class="line"> <span class="number">1</span> <span class="number">0</span> <span class="number">0 399392</span> <span class="number">220280</span> <span class="number">6405804 0</span> <span class="number">0 1 4 1</span> <span class="number">2 1 0 98</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0 398648</span> <span class="number">220280</span> <span class="number">6405960 0</span> <span class="number">0</span> <span class="number">0 25 2725</span> <span class="number">2284 2 0</span> <span class="number">98</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0 398648</span> <span class="number">220280</span> <span class="number">6406036 0</span> <span class="number">0</span> <span class="number">0 91 2652</span> <span class="number">2255 2 0</span> <span class="number">97</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span> <span class="number">0</span> <span class="number">0 398384</span> <span class="number">220280</span> <span class="number">6406080 0</span> <span class="number">0 0 112</span> <span class="number">2539 2180</span> <span class="number">2 0 98 0</span> <span class="number">0</span></span><br><span class="line"> <span class="number">1</span> <span class="number">0</span> <span class="number">0 398352</span> <span class="number">220280</span> <span class="number">6406184 0</span> <span class="number">0</span> <span class="number">0 0 2724</span> <span class="number">2230 2 0</span> <span class="number">98</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"> r：等待在CPU资源的进程数。这个数据比平均负载更加能够体现CPU负载情况。如果这个数值大于机器CPU核数，那么机器的CPU资源已经饱和。</span><br><span class="line">si, so：交换区写入和读取的数量。如果这个数据不为<span class="number">0</span>，说明系统已经在使用交换区（swap），机器物理内存已经不足。</span><br><span class="line">us, sy, id, wa, st：这些都代表了CPU时间的消耗，它们分别表示用户时间（user）、系统（内核）时间（sys）、空闲时间（idle）、IO等待时间（wait）和被偷走的时间（stolen，一般被其他虚拟机消耗）。</span><br><span class="line">一般情况下，如果用户时间和系统时间相加非常大，CPU处于忙于执行指令。如果IO等待时间很长，那么系统的瓶颈可能在磁盘IO。</span><br></pre></td></tr></table></figure></li><li><p>top</p><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4></li><li>sar<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sar</span> <span class="selector-tag">-n</span> &#123; <span class="selector-tag">DEV</span> | <span class="selector-tag">EDEV</span> | <span class="selector-tag">NFS</span> | <span class="selector-tag">NFSD</span> | <span class="selector-tag">SOCK</span> | <span class="keyword">ALL</span> &#125;</span><br><span class="line"><span class="selector-tag">DEV</span>显示网络接口信息，</span><br><span class="line"><span class="selector-tag">EDEV</span>显示关于网络错误的统计数据，</span><br><span class="line"><span class="selector-tag">NFS</span>统计活动的<span class="selector-tag">NFS</span>客户端的信息，</span><br><span class="line"><span class="selector-tag">NFSD</span>统计<span class="selector-tag">NFS</span>服务器的信息，</span><br><span class="line"><span class="selector-tag">SOCK</span>显示套接字信息，</span><br><span class="line"><span class="keyword">ALL</span>显示所有<span class="selector-tag">5</span>个开关</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[root@iZbp10fstdmbee21wif5ngZ 2018-02-26]</span># <span class="selector-tag">sar</span> <span class="selector-tag">-n</span> <span class="selector-tag">SOCK</span> <span class="selector-tag">2</span> <span class="selector-tag">10</span></span><br><span class="line"><span class="selector-tag">Linux</span> <span class="selector-tag">3</span><span class="selector-class">.10</span><span class="selector-class">.0-514</span><span class="selector-class">.6</span><span class="selector-class">.2</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span> (iZbp10fstdmbee21wif5ngZ) <span class="selector-tag">02</span>/<span class="selector-tag">27</span>/<span class="selector-tag">2018</span> <span class="selector-tag">_x86_64_</span>(<span class="number">8</span> CPU)</span><br><span class="line"><span class="selector-tag">05</span><span class="selector-pseudo">:07</span><span class="selector-pseudo">:33</span> <span class="selector-tag">PM</span> <span class="selector-tag">totsck</span> <span class="selector-tag">tcpsck</span> <span class="selector-tag">udpsck</span> <span class="selector-tag">rawsck</span> <span class="selector-tag">ip-frag</span> <span class="selector-tag">tcp-tw</span></span><br><span class="line"><span class="selector-tag">05</span><span class="selector-pseudo">:07</span><span class="selector-pseudo">:35</span> <span class="selector-tag">PM</span> <span class="selector-tag">265</span> <span class="selector-tag">163</span> <span class="selector-tag">4</span> <span class="selector-tag">0</span> <span class="selector-tag">0</span> <span class="selector-tag">12</span></span><br><span class="line"><span class="selector-tag">05</span><span class="selector-pseudo">:07</span><span class="selector-pseudo">:37</span> <span class="selector-tag">PM</span> <span class="selector-tag">265</span> <span class="selector-tag">163</span> <span class="selector-tag">4</span> <span class="selector-tag">0</span> <span class="selector-tag">0</span> <span class="selector-tag">12</span></span><br><span class="line"><span class="selector-tag">totsck</span>:使用的套接字总数量</span><br><span class="line"><span class="selector-tag">tcpsck</span>:使用的<span class="selector-tag">TCP</span>套接字数量</span><br><span class="line"><span class="selector-tag">udpsck</span>:使用的<span class="selector-tag">UDP</span>套接字数量</span><br><span class="line"><span class="selector-tag">rawsck</span>:使用的<span class="selector-tag">raw</span>套接字数量</span><br><span class="line"><span class="selector-tag">ip-frag</span>:使用的<span class="selector-tag">IP</span>段数量</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[root@iZbp10fstdmbee21wif5ngZ 2018-02-26]</span># <span class="selector-tag">sar</span> <span class="selector-tag">-n</span> <span class="selector-tag">DEV</span> <span class="selector-tag">2</span> <span class="selector-tag">10</span></span><br><span class="line"><span class="selector-tag">Linux</span> <span class="selector-tag">3</span><span class="selector-class">.10</span><span class="selector-class">.0-514</span><span class="selector-class">.6</span><span class="selector-class">.2</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span> (iZbp10fstdmbee21wif5ngZ) <span class="selector-tag">02</span>/<span class="selector-tag">27</span>/<span class="selector-tag">2018</span> <span class="selector-tag">_x86_64_</span>(<span class="number">8</span> CPU)</span><br><span class="line"><span class="selector-tag">05</span><span class="selector-pseudo">:12</span><span class="selector-pseudo">:43</span> <span class="selector-tag">PM</span> <span class="selector-tag">IFACE</span> <span class="selector-tag">rxpck</span>/<span class="selector-tag">s</span> <span class="selector-tag">txpck</span>/<span class="selector-tag">s</span> <span class="selector-tag">rxkB</span>/<span class="selector-tag">s</span> <span class="selector-tag">txkB</span>/<span class="selector-tag">s</span> <span class="selector-tag">rxcmp</span>/<span class="selector-tag">s</span> <span class="selector-tag">txcmp</span>/<span class="selector-tag">s</span> <span class="selector-tag">rxmcst</span>/<span class="selector-tag">s</span></span><br><span class="line"><span class="selector-tag">05</span><span class="selector-pseudo">:12</span><span class="selector-pseudo">:45</span> <span class="selector-tag">PM</span> <span class="selector-tag">eth0</span> <span class="selector-tag">535</span><span class="selector-class">.50</span> <span class="selector-tag">397</span><span class="selector-class">.00</span> <span class="selector-tag">58</span><span class="selector-class">.26</span> <span class="selector-tag">67</span><span class="selector-class">.17</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span></span><br><span class="line"><span class="selector-tag">05</span><span class="selector-pseudo">:12</span><span class="selector-pseudo">:45</span> <span class="selector-tag">PM</span> <span class="selector-tag">eth1</span> <span class="selector-tag">11</span><span class="selector-class">.50</span> <span class="selector-tag">13</span><span class="selector-class">.00</span> <span class="selector-tag">4</span><span class="selector-class">.18</span> <span class="selector-tag">2</span><span class="selector-class">.49</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span></span><br><span class="line"><span class="selector-tag">05</span><span class="selector-pseudo">:12</span><span class="selector-pseudo">:45</span> <span class="selector-tag">PM</span> <span class="selector-tag">lo</span> <span class="selector-tag">1</span><span class="selector-class">.50</span> <span class="selector-tag">1</span><span class="selector-class">.50</span> <span class="selector-tag">0</span><span class="selector-class">.09</span> <span class="selector-tag">0</span><span class="selector-class">.09</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span></span><br><span class="line"><span class="selector-tag">IFACE</span>：<span class="selector-tag">LAN</span>接口</span><br><span class="line"><span class="selector-tag">rxpck</span>/<span class="selector-tag">s</span>：每秒钟接收的数据包</span><br><span class="line"><span class="selector-tag">txpck</span>/<span class="selector-tag">s</span>：每秒钟发送的数据包</span><br><span class="line"><span class="selector-tag">rxbyt</span>/<span class="selector-tag">s</span>：每秒钟接收的字节数</span><br><span class="line"><span class="selector-tag">txbyt</span>/<span class="selector-tag">s</span>：每秒钟发送的字节数</span><br><span class="line"><span class="selector-tag">rxcmp</span>/<span class="selector-tag">s</span>：每秒钟接收的压缩数据包</span><br><span class="line"><span class="selector-tag">txcmp</span>/<span class="selector-tag">s</span>：每秒钟发送的压缩数据包</span><br><span class="line"><span class="selector-tag">rxmcst</span>/<span class="selector-tag">s</span>：每秒钟接收的多播数据包</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[root@iZbp10fstdmbee21wif5ngZ 2018-02-26]</span># <span class="selector-tag">sar</span> <span class="selector-tag">-n</span> <span class="selector-tag">EDEV</span> <span class="selector-tag">2</span> <span class="selector-tag">10</span></span><br><span class="line"><span class="selector-tag">Linux</span> <span class="selector-tag">3</span><span class="selector-class">.10</span><span class="selector-class">.0-514</span><span class="selector-class">.6</span><span class="selector-class">.2</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span> (iZbp10fstdmbee21wif5ngZ) <span class="selector-tag">02</span>/<span class="selector-tag">27</span>/<span class="selector-tag">2018</span> <span class="selector-tag">_x86_64_</span>(<span class="number">8</span> CPU)</span><br><span class="line"><span class="selector-tag">05</span><span class="selector-pseudo">:13</span><span class="selector-pseudo">:47</span> <span class="selector-tag">PM</span> <span class="selector-tag">IFACE</span> <span class="selector-tag">rxerr</span>/<span class="selector-tag">s</span> <span class="selector-tag">txerr</span>/<span class="selector-tag">s</span> <span class="selector-tag">coll</span>/<span class="selector-tag">s</span> <span class="selector-tag">rxdrop</span>/<span class="selector-tag">s</span> <span class="selector-tag">txdrop</span>/<span class="selector-tag">s</span> <span class="selector-tag">txcarr</span>/<span class="selector-tag">s</span> <span class="selector-tag">rxfram</span>/<span class="selector-tag">s</span> <span class="selector-tag">rxfifo</span>/<span class="selector-tag">s</span> <span class="selector-tag">txfifo</span>/<span class="selector-tag">s</span></span><br><span class="line"><span class="selector-tag">05</span><span class="selector-pseudo">:13</span><span class="selector-pseudo">:49</span> <span class="selector-tag">PM</span> <span class="selector-tag">eth0</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span></span><br><span class="line"><span class="selector-tag">05</span><span class="selector-pseudo">:13</span><span class="selector-pseudo">:49</span> <span class="selector-tag">PM</span> <span class="selector-tag">eth1</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span> <span class="selector-tag">0</span><span class="selector-class">.00</span></span><br><span class="line"><span class="selector-tag">IFACE</span>：<span class="selector-tag">LAN</span>接口</span><br><span class="line"><span class="selector-tag">rxerr</span>/<span class="selector-tag">s</span>：每秒钟接收的坏数据包</span><br><span class="line"><span class="selector-tag">txerr</span>/<span class="selector-tag">s</span>：每秒钟发送的坏数据包</span><br><span class="line"><span class="selector-tag">coll</span>/<span class="selector-tag">s</span>：每秒冲突数</span><br><span class="line"><span class="selector-tag">rxdrop</span>/<span class="selector-tag">s</span>：因为缓冲充满，每秒钟丢弃的已接收数据包数</span><br><span class="line"><span class="selector-tag">txdrop</span>/<span class="selector-tag">s</span>：因为缓冲充满，每秒钟丢弃的已发送数据包数</span><br><span class="line"><span class="selector-tag">txcarr</span>/<span class="selector-tag">s</span>：发送数据包时，每秒载波错误数</span><br><span class="line"><span class="selector-tag">rxfram</span>/<span class="selector-tag">s</span>：每秒接收数据包的帧对齐错误数</span><br><span class="line"><span class="selector-tag">rxfifo</span>/<span class="selector-tag">s</span>：接收的数据包每秒<span class="selector-tag">FIFO</span>过速的错误数</span><br><span class="line"><span class="selector-tag">txfifo</span>/<span class="selector-tag">s</span>：发送的数据包每秒<span class="selector-tag">FIFO</span>过速的错误数</span><br></pre></td></tr></table></figure></li></ol><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><ol><li>iostat(具体查看manual)<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eg.</span><br><span class="line">iostat -d -k <span class="number">1</span> <span class="number">10</span> #查看TPS和吞吐量信息</span><br><span class="line">iostat -d -x -k <span class="number">1</span> <span class="number">10</span> #查看设备使用率（%util）、响应时间（await）</span><br><span class="line">iostat -c <span class="number">1</span> <span class="number">10</span> #查看cpu状态</span><br><span class="line">[root@iZbp10fstdmbee21wif5ngZ <span class="number">2018-02-26</span>]# iostat -d -x -k <span class="number">1</span> <span class="number">10</span></span><br><span class="line">Linux <span class="number">3</span>.<span class="number">10.0-514</span>.<span class="number">6</span>.<span class="number">2</span>.el7.x86_64 (iZbp10fstdmbee21wif5ngZ) <span class="number">02/27/2018</span> _x86_64_(<span class="number">8</span> CPU)</span><br><span class="line">Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util</span><br><span class="line">vda <span class="number">0.01 4.32</span> <span class="number">0.51 2.99</span> <span class="number">18.01 32.07</span> <span class="number">28.56 0.04</span> <span class="number">11.71 60.41</span> <span class="number">3.34 0.73</span> <span class="number">0</span>.<span class="number">26</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ol><li>grep<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">  -R 递归</span><br><span class="line">  -w 按单词查找</span><br><span class="line">  -l 列出文件名</span><br><span class="line">  -i 忽略大小写</span><br><span class="line">  --<span class="keyword">exclude</span>=　排除</span><br><span class="line">  --<span class="keyword">exclude</span>-dir　排除目录</span><br><span class="line">  -n　输出行号</span><br><span class="line">  -v   反向，即不包含</span><br><span class="line">eg.搜索内容包含指定字符串的文件</span><br><span class="line">  <span class="keyword">grep</span> -s xxx <span class="regexp">/etc/</span>*</span><br><span class="line">  <span class="keyword">grep</span> -R xxx <span class="regexp">/etc/</span>*        包含子目录递归搜索</span><br><span class="line">  <span class="keyword">grep</span> -Rw xxx <span class="regexp">/etc/</span>*      w-不会查找出包含xxxy的</span><br><span class="line">  <span class="keyword">grep</span> -Rl xxx <span class="regexp">/etc/</span>*        只输出文件名</span><br><span class="line">  <span class="keyword">grep</span> -Ril xxx <span class="regexp">/etc/</span>*        忽略大小写</span><br><span class="line">  <span class="keyword">grep</span> -Ril xxx <span class="regexp">/etc/</span>*.conf</span><br><span class="line">  <span class="keyword">grep</span> -Ril --<span class="keyword">exclude</span>=\*.conf xxx <span class="regexp">/etc/</span>*   .conf文件不查找</span><br><span class="line">  <span class="keyword">grep</span> --<span class="keyword">exclude</span>-dir=<span class="regexp">/etc/g</span>rub.d -Rwl xxx <span class="regexp">/etc/</span>*  排除<span class="regexp">/etc/g</span>rub.d目录</span><br><span class="line">  <span class="keyword">grep</span> -Rni xxx <span class="regexp">/etc/</span>*.conf n-输出字符串所在行行号</span><br><span class="line">  <span class="keyword">grep</span> -Rlv xxx <span class="regexp">/etc/</span>*  查找出所有不包含xxx的文件</span><br></pre></td></tr></table></figure></li></ol><h2 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h2><p>除了基本的会计键外，可以通过修改vim的配置文件实现编译运行程序(在 VimScript 中函数名必须以大写字母开头，否则 Vim 将提示错误；exec 关键字之后的都会在Vim 的命令模式下执行)</p><p><img src="http://upload-images.jianshu.io/upload_images/3341325-948dfd8baa0cb1b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="create functions in vim .vimrc"><br>类似地：<br><img src="http://upload-images.jianshu.io/upload_images/3341325-9535fd7a41a09db2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="create function in vim for python"></p><p><img src="http://upload-images.jianshu.io/upload_images/3341325-49e59bb7f5b83f88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="create function in vim for java"><br>autocmd 实现这个，执行不同程序设计语言编译出的代码。<br><img src="http://upload-images.jianshu.io/upload_images/3341325-962de92314dd0be0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="autocmd in vimrc"></p><h2 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h2><p> Ubuntu，已经不用了，经常会有bug和包的冲突，可定制性也不高。</p><blockquote><p>爱上archlinux的原因</p></blockquote><ul><li><p>档案安装Wiki一步步装完archlinux的时候，你会惊讶于这个OS的勇气，始终坚持Keep simple的理念。呈现在你面前的只有一个虚拟终端。这其实意味着你需要付出更多的努力，但是却能保证打造出你最喜欢的系统，真正属于你的。</p></li><li><p>如果你还不够厉害（just like me），安装显卡驱动和xorg，再配上一个awesome或者其他的窗口管理器，就可以开始你的探险之旅了。</p><blockquote><p>推荐给你的软件</p></blockquote></li></ul><ul><li>vimfx 一款用vim方式操作firefox（pacman -S flashplugin安装flash）的插件。</li><li>zsh 一款好用的终端。</li><li>awesome主题 <a href="https://github.com/copycat-killer/awesome-copycats" target="_blank" rel="noopener">awesome-copycats</a>等。<blockquote><p>未完待续</p></blockquote></li></ul><h3 id="问题记录："><a href="#问题记录：" class="headerlink" title="问题记录："></a>问题记录：</h3><h4 id="1-bios中没有arch引导项或选择arch后，grub-进入rescue模式，提示unknown-file-system"><a href="#1-bios中没有arch引导项或选择arch后，grub-进入rescue模式，提示unknown-file-system" class="headerlink" title="1.bios中没有arch引导项或选择arch后，grub 进入rescue模式，提示unknown file system"></a>1.bios中没有arch引导项或选择arch后，grub 进入rescue模式，提示unknown file system</h4><blockquote><p>可以通过easyUEFI，管理efi启动项</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3341325-1a30e678250ff848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择esp启动分区"></p><p><img src="http://upload-images.jianshu.io/upload_images/3341325-96c3f550011e16c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择grubx64.efi所在"></p><blockquote><p>在grub rescue模式中，也可以通过输入以下命令进入Linux系统</p><ul><li>ls</li><li>ls 各个分区，找到文件系统为fat的启动分区，unknown即不是（diskgenius辅助）</li><li>set root=(hd1，gpt5)     设置启动分区</li><li>prefix= /grub  （x86_64-efi所在的目录）</li><li>insmod normal<br>以上步骤没错的话，输入以下命令可进入grub菜单，否则是这两个参数有错</li><li>normal</li></ul></blockquote><ul><li>按e编辑启动项为刚刚的分区，ctrl+x引导，最后进入系统后修改grub.cfg(用grub-mkconfig -o /boot/grub/grub.cfg自动生成)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;性能查看命令&quot;&gt;&lt;a href=&quot;#性能查看命令&quot; class=&quot;headerlink&quot; title=&quot;性能查看命令&quot;&gt;&lt;/a&gt;性能查看命令&lt;/h2&gt;&lt;h4 id=&quot;java相关&quot;&gt;&lt;a href=&quot;#java相关&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Linux" scheme="http://gitsarp.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://gitsarp.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Vim实用技巧——持续更新</title>
    <link href="http://gitsarp.github.io/Linux/Vim%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://gitsarp.github.io/Linux/Vim实用技巧/</id>
    <published>2018-07-01T13:31:48.000Z</published>
    <updated>2018-08-29T15:12:25.930Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vim实用技巧——持续更新"><a href="#Vim实用技巧——持续更新" class="headerlink" title="Vim实用技巧——持续更新"></a>Vim实用技巧——持续更新</h3><h4 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h4><ul><li>u undo</li><li><p><strong><c-r> reundo</c-r></strong></p><h5 id="操作符-动作命令-操作"><a href="#操作符-动作命令-操作" class="headerlink" title="操作符+动作命令=操作"></a>操作符+动作命令=操作</h5><p>操作符单独不可用，像c(change）、d（delete）、y（复制）,:h operator可以查看所有的有限操作符;: h :map-operator查看如何自定义操作符</p></li><li><p><strong>C重写当前位置到行尾</strong>,=c$</p></li><li><strong>D删除当前到行尾</strong>,=d$</li><li>y有点不同，Y=yy复制整行</li><li><strong>cb/db/yb改变删除或复制当前单词到光标处前</strong></li><li><strong>caw/daw/yaw替换删除或复制光标所在单词+后边的空格</strong></li><li>cc 重写当前行</li><li>dd删除当前行</li></ul><p>-guaw/gUaw/g~aw改变当前单词的大小写(全部变)</p><h5 id="复合命令"><a href="#复合命令" class="headerlink" title="复合命令"></a>复合命令</h5><ul><li><strong>A=$a</strong></li><li><strong>I=^i</strong></li><li><strong>S重写当前行</strong>,=cc=^C</li><li><strong>s当前字符替换成一个字符串</strong>,=cl</li><li><strong>.重复上次修改(微型宏）</strong></li></ul><h5 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h5><ul><li>qx{operations}q录制宏</li><li>@x进行宏的执行(.不能重复宏的执行,只能重复最近的一次修改)</li></ul><h4 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h4><ul><li><strong><c-w>删除前一个单词</c-w></strong></li><li><strong><c-u>删除至行首</c-u></strong></li><li><strong>&lt;c-[&gt;切换到正常模式，代替esc</strong></li><li><strong><c-o>切换到正常模式执行后返回</c-o></strong></li><li><c-r><register index="">复制寄存器的内容</register></c-r></li><li><c-r>=计算的值插入当前光标处<h4 id="替换模式"><a href="#替换模式" class="headerlink" title="替换模式"></a>替换模式</h4></c-r></li><li>R，或者Insert键<h4 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h4>V/<c-v> 行和列选<br>gv选中上次的区域<br>o切换高亮选区的活动端<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4></c-v></li></ul><ol><li>查找/替换<br>f/<strong>F</strong>单行查找</li></ol><ul><li><strong>；顺着方向查</strong></li><li><strong>，逆着方向查</strong><br>/string全局查找,或:/string</li><li>n/N<br>全局替换<br>：%s/olds/news/g<br><strong>手动遍历替换(完整匹配单词)</strong><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> *(完整匹配光标所在单词)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 选择性的cw</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> n</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> .</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>若干行尾部加同样的东西，如；</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> $</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> c-v</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 移动来选中行(eg.5j)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> A</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> esc</span></span><br><span class="line"></span><br><span class="line">同样的行首加</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ^;c-v；移动来选中行；I；&lt;head&gt;;esc；</span></span><br></pre></td></tr></table></figure><ol start="3"><li>调整代码格式</li></ol><ul><li><blockquote><p>/&lt;/=缩进(操作符）</p><blockquote><p>/&lt;&lt;/==缩进当前行<br>G/&lt;G/=G缩进当前行到尾行</p></blockquote></blockquote></li><li>拼接字符串的‘+’变为‘ + ’</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> f</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> +</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> s</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> space + space esc</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> **;**</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> .</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ;.</span></span><br></pre></td></tr></table></figure><ul><li>注释<br>安装commentary.vim 插件，提供了gc操作符<br>gcc注释当前行<br>gcG<br>gcap</li></ul><ol start="4"><li>数字运算</li></ol><ul><li><c-x>/<c-a> 对当前光标下或其后的第一个数字执行减减或加加</c-a></c-x></li><li>5<c-x>/<c-a> = -5/+5</c-a></c-x></li><li>Insert mode  <c-r>=插入运算结果到当前位置</c-r></li></ul><ol start="5"><li>写作</li></ol><ul><li>zz调整当前行到屏幕中央，c-o zz</li></ul><ol start="6"><li>划线</li></ol><ul><li>横线<blockquote><p>yyp<br>Vr-</p></blockquote></li><li>竖线<blockquote><p><c-v>9j<br>r|</c-v></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vim实用技巧——持续更新&quot;&gt;&lt;a href=&quot;#Vim实用技巧——持续更新&quot; class=&quot;headerlink&quot; title=&quot;Vim实用技巧——持续更新&quot;&gt;&lt;/a&gt;Vim实用技巧——持续更新&lt;/h3&gt;&lt;h4 id=&quot;普通模式&quot;&gt;&lt;a href=&quot;#普通模式&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://gitsarp.github.io/categories/Linux/"/>
    
    
      <category term="vim" scheme="http://gitsarp.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>bootstrap</title>
    <link href="http://gitsarp.github.io/%E5%89%8D%E7%AB%AF/bootstrap/"/>
    <id>http://gitsarp.github.io/前端/bootstrap/</id>
    <published>2018-07-01T13:31:22.000Z</published>
    <updated>2018-07-03T13:38:48.147Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-栅格系统"><a href="#1-栅格系统" class="headerlink" title="1.栅格系统"></a>1.栅格系统</h4><p>总共12列，col-xs-6 col-sm-3 col-md（超小屏幕，小，中等）占的列宽<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"page-header"</span>&gt;</span><br><span class="line">    &lt;h1&gt;案例:Responsive column resets&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"row"</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=<span class="string">"col-xs-6 col-sm-3"</span>&gt;<span class="selector-class">.col-xs-6</span> .col-sm-<span class="number">3</span>(通过调整浏览器的宽度或在手机上即可查看这些案例的实际效果。)&lt;/div&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=<span class="string">"col-xs-6 col-sm-3"</span>&gt;<span class="selector-class">.col-xs-6</span> .col-sm-<span class="number">3</span>&lt;/div&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=<span class="string">"clearfix visible-xs"</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=<span class="string">"col-xs-6 col-sm-3"</span>&gt;<span class="selector-class">.col-xs-6</span> .col-sm-<span class="number">3</span>&lt;/div&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=<span class="string">"col-xs-6 col-sm-3"</span>&gt;<span class="selector-class">.col-xs-6</span> .col-sm-<span class="number">3</span>&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>超小效果：<br><img src="http://upload-images.jianshu.io/upload_images/3341325-c3fdc0bc769e437a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>不加<div class="clearfix visible-xs"></div>，超小效果：<br><img src="http://upload-images.jianshu.io/upload_images/3341325-24143326d1bc1cd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="2-列偏移"><a href="#2-列偏移" class="headerlink" title="2.列偏移"></a>2.列偏移</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"page-header"</span>&gt;</span><br><span class="line">    &lt;h1&gt;案例:列偏移&lt;/h1&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"row"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"col-md-4"</span>&gt;.col-md<span class="number">-4</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"col-md-4 col-md-offset-4"</span>&gt;.col-md<span class="number">-4</span> .col-md-<span class="built_in">offset</span><span class="number">-4</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"row"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"col-md-3 col-md-offset-3"</span>&gt;.col-md<span class="number">-3</span> .col-md-<span class="built_in">offset</span><span class="number">-3</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"col-md-3 col-md-offset-3"</span>&gt;.col-md<span class="number">-3</span> .col-md-<span class="built_in">offset</span><span class="number">-3</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"row"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"col-md-6 col-md-offset-3"</span>&gt;.col-md<span class="number">-6</span> .col-md-<span class="built_in">offset</span><span class="number">-3</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>效果：<br><img src="http://upload-images.jianshu.io/upload_images/3341325-7448798212e0e9dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-栅格系统&quot;&gt;&lt;a href=&quot;#1-栅格系统&quot; class=&quot;headerlink&quot; title=&quot;1.栅格系统&quot;&gt;&lt;/a&gt;1.栅格系统&lt;/h4&gt;&lt;p&gt;总共12列，col-xs-6 col-sm-3 col-md（超小屏幕，小，中等）占的列宽&lt;br&gt;&lt;figu
      
    
    </summary>
    
      <category term="前端" scheme="http://gitsarp.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Bootstrap" scheme="http://gitsarp.github.io/tags/Bootstrap/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://gitsarp.github.io/%E7%AE%97%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/%E7%AE%97%E6%B3%95/"/>
    <id>http://gitsarp.github.io/算法及实现/算法/</id>
    <published>2018-07-01T13:23:14.000Z</published>
    <updated>2018-08-29T15:37:22.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单链表逆置"><a href="#单链表逆置" class="headerlink" title="单链表逆置"></a>单链表逆置</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> reverseNodeList() &#123;</span><br><span class="line">    <span class="comment">//创建单链表9,8,7...0</span></span><br><span class="line">    Node curr=<span class="keyword">null</span>;<span class="comment">//初始化尾节点为空</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        Node tmp=<span class="keyword">new</span> Node(curr,i);</span><br><span class="line">        curr=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆转</span></span><br><span class="line">    Node prev=<span class="keyword">null</span>;<span class="comment">//前一个节点默认为空</span></span><br><span class="line">    <span class="keyword">while</span> (curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr==<span class="keyword">null</span>||curr.<span class="keyword">next</span>==<span class="keyword">null</span>) &#123;</span><br><span class="line">            curr.<span class="keyword">next</span>=prev;<span class="comment">//如果当前节点或他的下一个节点为空，就使他指向前一个节点</span></span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//结束，否则极易造成死循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node tmp=curr.<span class="keyword">next</span>;<span class="comment">//保存当前节点的下一个节点，作为下次循环的curr</span></span><br><span class="line">        curr.<span class="keyword">next</span>=prev;<span class="comment">//当前节点指向前一个节点</span></span><br><span class="line">        prev=curr;<span class="comment">//当前节点变下一次循环的前一个节点</span></span><br><span class="line">        curr=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断单链表相交"><a href="#判断单链表相交" class="headerlink" title="判断单链表相交"></a>判断单链表相交</h2><h3 id="问题a：两链表都是没环的"><a href="#问题a：两链表都是没环的" class="headerlink" title="问题a：两链表都是没环的"></a>问题a：两链表都是没环的</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">问题a：</span><br><span class="line"><span class="number">1.</span>因为都是单链表，所以在相交之后，相交点之后都是一样的节点，最后一个节点也一定是一样的(类推)</span><br><span class="line"><span class="number">2.</span>将A的尾节点指向b的头结点，B循环到尾节点，如果是b的头结点，也是证明最后一个节点是一样的</span><br></pre></td></tr></table></figure><h3 id="问题b：两链表环的情况不知道"><a href="#问题b：两链表环的情况不知道" class="headerlink" title="问题b：两链表环的情况不知道"></a>问题b：两链表环的情况不知道</h3><p><strong>先用追逐法判断单链表是否有环</strong><br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">判断有环的就是p<span class="number">0</span>和p<span class="number">1</span>都指向头结点，然后每次<span class="number">1</span>走一步，b走两步，看走到的点是不是相同</span><br><span class="line"><span class="comment">(可以这么去理解，有n个站台，a每次走一个站台，b每次走两个，如果这是个线性的那么b永远在a前面，如果有环，就是b得往回走，那么a，肯定是会相遇的，会有可能不相遇吗？如果b不是走两步的话，是有可能的，b的步伐太大，正好跳过了相遇点，但是每次走两步，假设跳过去相遇点，那么就应该是相遇点的前一个节点，那么相遇点实际上就有两个方向了，这就与单链表相矛盾了)</span></span><br></pre></td></tr></table></figure></p><p>3种情形，都没环就是问题a，1个有环1个无环不可能相交，<strong>两个都有环还相交，环一定是共有的，即a环的相遇点在b的环上</strong>(记住吧)</p><h2 id="找出第一个相交点"><a href="#找出第一个相交点" class="headerlink" title="找出第一个相交点"></a>找出第一个相交点</h2><ul><li><p>如果都没环（相交类比成一个Y字型），同样A的尾节点指向b的头结点，转换成用追逐法求环的那个偶遇点问题</p></li><li><p>剩下两个都有环的情况，<br>计算出两链表的长度lA、lB，（环的长度和环到入口点长度之和就是链表长度）<br>如果lA&gt;lB，则链表A指针先走lA-lB，然后链表B指针开始走，两者相遇的点就是相交点<br>如果lB&gt;lA，则链表B指针先走lB-lA，然后链表A指针开始走，两者相遇的点就是相交点</p></li></ul><h2 id="一、排序"><a href="#一、排序" class="headerlink" title="一、排序"></a>一、排序</h2><p>排序分内部排序和外部排序（需不需要访问外存）<br>排序算法的稳定是值排序后 2 个相等键值的顺序和排序之前它们的顺序相同</p><h4 id="1-冒泡排序（n-2-最好n-最差n-2-内部稳定）"><a href="#1-冒泡排序（n-2-最好n-最差n-2-内部稳定）" class="headerlink" title="1.冒泡排序（n^2,最好n,最差n^2,内部稳定）"></a>1.冒泡排序（n^2,最好n,最差n^2,内部稳定）</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我自己的，理解更合自己的胃口</span></span><br><span class="line">   boolean noSwarp=<span class="literal">true</span>;</span><br><span class="line">   <span class="type">int</span>[] b=&#123;<span class="number">8</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.<span class="built_in">length</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">       noSwarp=<span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=b.<span class="built_in">length</span><span class="number">-1</span>;j&gt;i;j--)&#123;</span><br><span class="line">           <span class="keyword">if</span> (b[j]&lt;b[j<span class="number">-1</span>]) &#123;</span><br><span class="line">               <span class="type">int</span> tmp=b[j];</span><br><span class="line">               b[j]=b[j<span class="number">-1</span>];</span><br><span class="line">               b[j<span class="number">-1</span>]=tmp;</span><br><span class="line">               noSwarp=<span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(noSwarp)&#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-选择排序（n-2-内部不稳定）"><a href="#2-选择排序（n-2-内部不稳定）" class="headerlink" title="2.选择排序（n^2,,内部不稳定）"></a>2.选择排序（n^2,,内部不稳定）</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class SelectionSort implements IArraySort &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] <span class="built_in">sort</span>(<span class="built_in">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总共要经过 N-1 轮比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">min</span> = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每轮需要比较的次数 N-i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[<span class="built_in">min</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 记录目前能找到的最小值元素的下标</span></span><br><span class="line">                    <span class="built_in">min</span> = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将找到的最小值和i位置所在的值进行交换</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="built_in">min</span>) &#123;</span><br><span class="line">                <span class="built_in">int</span> tmp = arr[i];</span><br><span class="line">                arr[i] = arr[<span class="built_in">min</span>];</span><br><span class="line">                arr[<span class="built_in">min</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-插入排序（n-2-最好n-最差n-2-内部稳定）"><a href="#3-插入排序（n-2-最好n-最差n-2-内部稳定）" class="headerlink" title="3.插入排序（n^2,最好n,最差n^2,内部稳定）"></a>3.插入排序（n^2,最好n,最差n^2,内部稳定）</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录要插入的数据</span></span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从已经排序的序列最右边的开始比较，找到比其小的数</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存在比其小的数，插入</span></span><br><span class="line">            <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-希尔排序（以插入排序为基础）"><a href="#4-希尔排序（以插入排序为基础）" class="headerlink" title="4.希尔排序（以插入排序为基础）"></a>4.希尔排序（以插入排序为基础）</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//选择合适的步长</span></span><br><span class="line">        <span class="keyword">while</span> (gap &lt; arr.length) &#123;</span><br><span class="line">            gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;<span class="comment">//从第一组的第二个数开始</span></span><br><span class="line">                <span class="keyword">int</span> tmp = arr[i];<span class="comment">//保存当前要插入的值</span></span><br><span class="line">                <span class="keyword">int</span> j = i - gap;<span class="comment">//循环调整有序组内元素位置</span></span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; tmp) &#123;</span><br><span class="line">                    arr[j + gap] = arr[j];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j + gap] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            gap = (<span class="keyword">int</span>) Math.floor(gap / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-快速排序（分治的思想）"><a href="#5-快速排序（分治的思想）" class="headerlink" title="5.快速排序（分治的思想）"></a>5.快速排序（分治的思想）</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) throws Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> partitionIndex = partition(arr, left, right);</span><br><span class="line">            quickSort(arr, left, partitionIndex - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//分区算法！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="comment">// 设定基准值（pivot）为最左边的数字</span></span><br><span class="line">        <span class="keyword">int</span> pivot = left;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">index</span> = pivot + <span class="number">1</span>;<span class="comment">//index表示小于基准值的右边界索引+1，初始化为   left+1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">index</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;<span class="comment">//大于基准值时直接过，不过index不再累加，等找到下一个小于基准值的，再交换</span></span><br><span class="line">                swap(arr, i, <span class="keyword">index</span>);</span><br><span class="line">                <span class="keyword">index</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivot, <span class="keyword">index</span> - <span class="number">1</span>);<span class="comment">//最后将基准值和小于基准值的右边界元素交换</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">index</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h4><p>Math.floor(n/2)的位置开始，不断调整堆，调整堆的操作是个递归的操作（例如建造大顶堆设置索引largest=i，将其和子节点三者最大值和i的值进行对调，largest指向原最大值的位置，如果i=largest，则递归结束了（因为堆的下面是有序的了），否则继续递归该节点）</p><h4 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a>7.归并排序</h4><p>不断将原序列切分成两个子序列，调用</p><h2 id="二、最长子序列和"><a href="#二、最长子序列和" class="headerlink" title="二、最长子序列和"></a>二、最长子序列和</h2><p>内容节选自 <a href="http://www.cnblogs.com/conw/p/5896155.html" target="_blank" rel="noopener">http://www.cnblogs.com/conw/p/5896155.html</a></p><h4 id="1-O-N-3-的算法"><a href="#1-O-N-3-的算法" class="headerlink" title="1.O(N^3)的算法"></a>1.O(N^3)的算法</h4><p>i从1到n，j从i到n，k从i到j算出以i，j为首尾的子序列的和，最大值即为所求。</p><h4 id="2-O-N-2-的算法"><a href="#2-O-N-2-的算法" class="headerlink" title="2.O(N^2)的算法"></a>2.O(N^2)的算法</h4><p>sum[i]表示从1到i的和，求出sum，从第i个数到第j个数的和即sum[j]-sum[i-1]。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//N是数组长度，num是待计算的数组，sum是数组前缀和，放在全局区是因为可以开很大的数组</span></span><br><span class="line"><span class="keyword">int</span> N, num[<span class="number">16384</span>], sum[<span class="number">16384</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入数据</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="comment">//计算数组前缀和</span></span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        sum[i] = num[i] + sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = num[<span class="number">1</span>]; <span class="comment">//ans保存最大子序列和，初始化为num[1]能保证最终结果正确</span></span><br><span class="line">    <span class="comment">//i和j分别是枚举的子序列的起点和终点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= N; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = sum[j] - sum[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s &gt; ans) ans = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-分治O-N-logN"><a href="#3-分治O-N-logN" class="headerlink" title="3.分治O(N*logN)"></a>3.分治O(N*logN)</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">//<span class="built_in">N</span>是数组长度，num是待计算的数组，放在全局区是因为可以开很大的数组</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">N</span>, num[<span class="number">16777216</span>];</span><br><span class="line"><span class="built_in">int</span> solve(<span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)</span><br><span class="line">&#123;</span><br><span class="line">    //序列长度为<span class="number">1</span>时</span><br><span class="line">    <span class="built_in">if</span>(<span class="built_in">left</span> == <span class="built_in">right</span>)</span><br><span class="line">        return num[<span class="built_in">left</span>];</span><br><span class="line">    //划分为两个规模更小的问题</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + <span class="built_in">right</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> lans = solve(<span class="built_in">left</span>, <span class="built_in">mid</span>);</span><br><span class="line">    <span class="built_in">int</span> rans = solve(<span class="built_in">mid</span> + <span class="number">1</span>, <span class="built_in">right</span>);</span><br><span class="line"> </span><br><span class="line">    //横跨分割点的情况</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>, lmax = num[<span class="built_in">mid</span>], rmax = num[<span class="built_in">mid</span> + <span class="number">1</span>];</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="built_in">mid</span>; i &gt;= <span class="built_in">left</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">sum</span> += num[i];</span><br><span class="line">        <span class="built_in">if</span>(<span class="built_in">sum</span> &gt; lmax) lmax = <span class="built_in">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="built_in">mid</span> + <span class="number">1</span>; i &lt;= <span class="built_in">right</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">sum</span> += num[i];</span><br><span class="line">        <span class="built_in">if</span>(<span class="built_in">sum</span> &gt; rmax) rmax = <span class="built_in">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //答案是三种情况的最大值</span><br><span class="line">    <span class="built_in">int</span> ans = lmax + rmax;</span><br><span class="line">    <span class="built_in">if</span>(lans &gt; ans) ans = lans;</span><br><span class="line">    <span class="built_in">if</span>(rans &gt; ans) ans = rans;</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    //输入数据</span><br><span class="line">    scanf(<span class="string">"%d"</span>, &amp;<span class="built_in">N</span>);</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">N</span>; i++)</span><br><span class="line">        scanf(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    printf(<span class="string">"%d\n"</span>, solve(<span class="number">1</span>, <span class="built_in">N</span>));</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-动态规划O-N"><a href="#4-动态规划O-N" class="headerlink" title="4.动态规划O(N)"></a>4.动态规划O(N)</h4><p>我们用dp[n]表示以第n个数结尾的最大连续子序列的和，于是存在以下递推公式：dp[n] = max(0, dp[n-1]) + num[n]<br>仔细思考后不难发现这个递推公式是正确的，则整个问题的答案是max(dp[m]) | m∈[1, N]。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//N是数组长度，num是待计算的数组，放在全局区是因为可以开很大的数组</span></span><br><span class="line"><span class="built_in">int</span> N, <span class="built_in">num</span>[<span class="number">134217728</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//输入数据</span></span><br><span class="line">    scanf(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        scanf(<span class="string">"%d"</span>, &amp;<span class="built_in">num</span>[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">num</span>[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> ans = <span class="built_in">num</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">num</span>[i - <span class="number">1</span>] &gt; <span class="number">0</span>) <span class="built_in">num</span>[i] += <span class="built_in">num</span>[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">num</span>[i] += <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">num</span>[i] &gt; ans) ans = <span class="built_in">num</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>没有创建另外的数组我感觉有点混乱…</p><h4 id="5-又一个O-N-的算法"><a href="#5-又一个O-N-的算法" class="headerlink" title="5.又一个O(N)的算法"></a>5.又一个O(N)的算法</h4><p>。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单链表逆置&quot;&gt;&lt;a href=&quot;#单链表逆置&quot; class=&quot;headerlink&quot; title=&quot;单链表逆置&quot;&gt;&lt;/a&gt;单链表逆置&lt;/h2&gt;&lt;figure class=&quot;highlight gradle&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
      <category term="算法及实现" scheme="http://gitsarp.github.io/categories/%E7%AE%97%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="算法" scheme="http://gitsarp.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式</title>
    <link href="http://gitsarp.github.io/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://gitsarp.github.io/Java/设计模式/</id>
    <published>2018-07-01T13:14:22.000Z</published>
    <updated>2018-07-11T14:12:59.654Z</updated>
    
    <content type="html"><![CDATA[<p> 六大原则 </p><pre><code>单一职责原理：一个类只负责一项职责。里氏替换原则：劲量不要重写父类的已经实现了的方法，可以用接口等其他方法绕开。依赖倒置原则：高层模块不应该依赖底层模块，二者应依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。接口隔离原则：客户端不应该依赖其他不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。迪米特法则：又叫做最小知道原则。就是一个类对自己依赖的类知道越少越好。开闭原则：尽量通过扩展软件实体行为来实现变化。</code></pre><p>可以分为三种：创建型、结构型和行为型</p><p>1.单例模式（singleton pattern）<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//饿汉</span><br><span class="line">public class EagerInitializedSingleton &#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span><span class="keyword"> final</span> EagerInitializedSingleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>EagerInitializedSingleton();</span><br><span class="line">    //private<span class="keyword"> constructor</span> to avoid client applications to use<span class="keyword"> constructor</span></span><br><span class="line">   <span class="keyword"> private</span> EagerInitializedSingleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> EagerInitializedSingleton getInstance()&#123;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//懒汉</span><br><span class="line">public class LazyInitializedSingleton &#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> <span class="class">LazyInitializedSingleton instance;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span> LazyInitializedSingleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    //加synchronized 就是线程安全的 </span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> synchronized LazyInitializedSingleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>LazyInitializedSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//双重加锁</span><br><span class="line">public<span class="keyword"> static</span> ThreadSafeSingleton getInstanceUsingDoubleLocking()&#123;</span><br><span class="line">    if(instance == null)&#123;</span><br><span class="line">        synchronized (ThreadSafeSingleton.class) &#123;</span><br><span class="line">            if(instance == null)&#123;</span><br><span class="line">               <span class="built_in"> instance </span>=<span class="built_in"> new </span>ThreadSafeSingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in"> return </span>instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用反射则单例模式无效！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionSingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">        EagerInitializedSingleton instanceOne = EagerInitializedSingleton.getInstance();</span><br><span class="line">        EagerInitializedSingleton instanceTwo = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor[] constructors = EagerInitializedSingleton.<span class="keyword">class</span>.getDeclaredConstructors();</span><br><span class="line">            <span class="keyword">for</span> (Constructor <span class="keyword">constructor</span> : constructors) &#123;</span><br><span class="line">                <span class="keyword">constructor</span>.setAccessible(<span class="literal">true</span>);<span class="comment">//important!</span></span><br><span class="line">                instanceTwo = (EagerInitializedSingleton) <span class="keyword">constructor</span>.newInstance();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(instanceOne.hashCode());</span><br><span class="line">        System.<span class="keyword">out</span>.println(instanceTwo.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.观察者模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 六大原则 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;单一职责原理：一个类只负责一项职责。
里氏替换原则：劲量不要重写父类的已经实现了的方法，可以用接口等其他方法绕开。
依赖倒置原则：高层模块不应该依赖底层模块，二者应依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
接口隔离原则：
      
    
    </summary>
    
      <category term="Java" scheme="http://gitsarp.github.io/categories/Java/"/>
    
    
      <category term="Java设计模式" scheme="http://gitsarp.github.io/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
