---
title: Java设计模式
date: 2018-07-01 21:14:22
tags: Java设计模式
categories: Java
---
 六大原则 

    单一职责原理：一个类只负责一项职责。
    里氏替换原则：劲量不要重写父类的已经实现了的方法，可以用接口等其他方法绕开。
    依赖倒置原则：高层模块不应该依赖底层模块，二者应依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
    接口隔离原则：客户端不应该依赖其他不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。
    迪米特法则：又叫做最小知道原则。就是一个类对自己依赖的类知道越少越好。
    开闭原则：尽量通过扩展软件实体行为来实现变化。

可以分为三种：创建型、结构型和行为型

1.单例模式（singleton pattern）
```
//饿汉
public class EagerInitializedSingleton {
    private static final EagerInitializedSingleton instance = new EagerInitializedSingleton();
    //private constructor to avoid client applications to use constructor
    private EagerInitializedSingleton(){}

    public static EagerInitializedSingleton getInstance(){
        return instance;
    }
}
```
```
//懒汉
public class LazyInitializedSingleton {
    private static LazyInitializedSingleton instance;
	
    private LazyInitializedSingleton(){}
	
    //加synchronized 就是线程安全的 
    public static synchronized LazyInitializedSingleton getInstance(){
        if(instance == null){
            instance = new LazyInitializedSingleton();
        }
        return instance;
    }
}
```
```
//双重加锁
public static ThreadSafeSingleton getInstanceUsingDoubleLocking(){
    if(instance == null){
        synchronized (ThreadSafeSingleton.class) {
            if(instance == null){
                instance = new ThreadSafeSingleton();
            }
        }
    }
    return instance;
}
```
```
//使用反射则单例模式无效！
public class ReflectionSingletonTest {

    public static void main(String[] args) {
        EagerInitializedSingleton instanceOne = EagerInitializedSingleton.getInstance();
        EagerInitializedSingleton instanceTwo = null;
        try {
            Constructor[] constructors = EagerInitializedSingleton.class.getDeclaredConstructors();
            for (Constructor constructor : constructors) {
                constructor.setAccessible(true);//important!
                instanceTwo = (EagerInitializedSingleton) constructor.newInstance();
                break;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(instanceOne.hashCode());
        System.out.println(instanceTwo.hashCode());
    }

}
```

2.观察者模式