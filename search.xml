<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[rocketmq]]></title>
    <url>%2FJava%2Frocketmq%2F</url>
    <content type="text"><![CDATA[quick-start 物理部署 Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。 Broker分为Master与Slave(主从配置)，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。 Producer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署 Consumer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。 编译安装4.2.0版本： git clone https://github.com/apache/rocketmq.git 编译 mvn -Prelease-all -DskipTests clean install -U 旧版本： git clone https://github.com/apache/incubator-rocketmq.git mvn clean package install -Prelease-all assembly:assembly -U 注意安装要求，maven是3.2.X否则可能会有问题(我的3.5.3运行quickstart的Consumer就有问题) 启动关闭:cd distribution/target/apache-rocketmq nohup sh bin/mqnamesrv &amp; nohup sh bin/mqbroker -n localhost:9876 autoCreateTopicEnable=true &amp;,不加autoCreateTopicEnable=true我这边启动Producer报No route info of this topic错 使用tail -f ~/logs/rocketmqlogs/XXX.log或jps查看是否启动成功，Ctrl c退出 使用sh bin/mqshutdown broker和sh bin/mqshutdown namesrv关闭 jar包依赖maven 12345678910111213141516commons-cli-1.2.jarcommons-lang3-3.4.jarfastjson-1.2.29.jarguava-19.0.jarjavassist-3.20.0-GA.jarjna-4.2.2.jarlogback-classic-1.0.13.jarlogback-core-1.0.13.jarnetty-all-4.0.36.Final.jaropenmessaging-api-0.1.0-alpha.jarrocketmq-client-4.2.0-incubating-SNAPSHOT.jarrocketmq-common-4.2.0-incubating-SNAPSHOT.jarrocketmq-remoting-4.2.0-incubating-SNAPSHOT.jarrocketmq-srvutil-4.2.0-incubating-SNAPSHOT.jarrocketmq-tools-4.2.0-incubating-SNAPSHOT.jarslf4j-api-1.7.5.jar 三种方式 同步——用在大规模分布场景下，像重要的通知消息，短信通知，短信市场系统等 12345678910111213141516171819202122public class SyncProducer &#123; public static void main(String[] args) throws Exception &#123; //Instantiate with a producer group name. DefaultMQProducer producer = new DefaultMQProducer("please_rename_unique_group_name"); //Launch the instance. producer.start(); for (int i = 0; i &lt; 100; i++) &#123; //Create a message instance, specifying topic, tag and message body. Message msg = new Message("TopicTest" /* Topic */, "TagA" /* Tag */, ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */ ); //Call send message to deliver message to one of brokers. SendResult sendResult = producer.send(msg); System.out.printf("%s%n", sendResult); &#125; //Shut down once the producer instance is not longer in use. producer.shutdown(); &#125;&#125; 异步——实时的业务场景 可以看出多了发送完的回调函数 12345678910111213141516171819202122232425262728293031public class AsyncProducer &#123; public static void main(String[] args) throws Exception &#123; //Instantiate with a producer group name. DefaultMQProducer producer = new DefaultMQProducer("ExampleProducerGroup"); //Launch the instance. producer.start(); producer.setRetryTimesWhenSendAsyncFailed(0); for (int i = 0; i &lt; 100; i++) &#123; final int index = i; //Create a message instance, specifying topic, tag and message body. Message msg = new Message("TopicTest", "TagA", "OrderID188", "Hello world".getBytes(RemotingHelper.DEFAULT_CHARSET)); producer.send(msg, new SendCallback() &#123; @Override public void onSuccess(SendResult sendResult) &#123; System.out.printf("%-10d OK %s %n", index, sendResult.getMsgId()); &#125; @Override public void onException(Throwable e) &#123; System.out.printf("%-10d Exception %s %n", index, e); e.printStackTrace(); &#125; &#125;); &#125; //Shut down once the producer instance is not longer in use. producer.shutdown(); &#125;&#125; 单向传输——对可靠性要求一般的场景，像日志搜集 123456789101112131415161718192021public class OnewayProducer &#123; public static void main(String[] args) throws Exception&#123; //Instantiate with a producer group name. DefaultMQProducer producer = new DefaultMQProducer("ExampleProducerGroup"); //Launch the instance. producer.start(); for (int i = 0; i &lt; 100; i++) &#123; //Create a message instance, specifying topic, tag and message body. Message msg = new Message("TopicTest" /* Topic */, "TagA" /* Tag */, ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */ ); //Call send message to deliver message to one of brokers. producer.sendOneway(msg); &#125; //Shut down once the producer instance is not longer in use. producer.shutdown(); &#125;&#125; 逻辑架构 队列集合称为Topic，Consumer如果做广播消费，则一个consumer实例消费这个Topic对应的所有队列，如果做集群消费，则多个Consumer实例平均消费这个topic对应的队列集合。 有序消息生产者从运行结果看，默认四条消息队列(queueid0-3)。消息的id(0~9)会发送到不同的消息队列上 123456789101112131415161718192021222324252627282930public static void main( String[] args ) throws Exception&#123; //Instantiate with a producer group name. MQProducer producer = new DefaultMQProducer("example_group_name"); //Launch the instance. //多个地址用分号隔开；也可以设置成环境变量 ((DefaultMQProducer) producer).setNamesrvAddr("127.0.0.1:9876"); producer.start(); String[] tags = new String[] &#123;"TagA", "TagB", "TagC", "TagD", "TagE"&#125;; for (int i = 0; i &lt; 100; i++) &#123; int orderId = i % 10; //Create a message instance, specifying topic, tag and message body. Message msg = new Message("TopicTestjjj", tags[i % tags.length], "KEY" + i, ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET)); SendResult sendResult = producer.send(msg, new MessageQueueSelector() &#123; @Override public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123; Integer id = (Integer) arg; //输出0~9 //System.out.println(id); int index = id % mqs.size();// 如果队列数不变，同一个订单号取到的队列是同一个 return mqs.get(index); &#125; &#125;, orderId);//orderId传递给回调方法 System.out.printf("%s%n", sendResult); &#125; //server shutdown producer.shutdown();&#125; 消费者 消费者消费指定主题的消息，并注册监听器，打印消息并根据收到的消息顺序返回不同的消费状态 实现MessageListenerOrderly的consumeMessage方法 CONSUME_FROM_LAST_OFFSET：第一次启动从队列最后位置消费，后续再启动接着上次消费的进度开始消费 CONSUME_FROM_FIRST_OFFSET：第一次启动从队列初始位置消费，后续再启动接着上次消费的进度开始消费 CONSUME_FROM_TIMESTAMP：第一次启动从指定时间点位置消费，后续再启动接着上次消费的进度开始消费 1234567891011121314151617181920212223242526272829303132333435public static void main (String[] args) throws Exception &#123; DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("example_group_name"); consumer.setNamesrvAddr("127.0.0.1:9876"); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.subscribe("TopicTest", "TagA || TagC || TagD"); consumer.registerMessageListener(new MessageListenerOrderly() &#123; AtomicLong consumeTimes = new AtomicLong(0); @Override public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) &#123; context.setAutoCommit(false); System.out.printf(Thread.currentThread().getName() + " Receive New Messages: " + msgs + "%n"); this.consumeTimes.incrementAndGet(); if ((this.consumeTimes.get() % 2) == 0) &#123; return ConsumeOrderlyStatus.SUCCESS; &#125; else if ((this.consumeTimes.get() % 3) == 0) &#123; return ConsumeOrderlyStatus.ROLLBACK; &#125; else if ((this.consumeTimes.get() % 4) == 0) &#123; return ConsumeOrderlyStatus.COMMIT; &#125; else if ((this.consumeTimes.get() % 5) == 0) &#123; context.setSuspendCurrentQueueTimeMillis(3000); return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT; &#125; return ConsumeOrderlyStatus.SUCCESS; &#125; &#125;); consumer.start(); System.out.printf("Consumer Started.%n");&#125; 广播模式 消费者设置：//set to broadcast mode consumer.setMessageModel(MessageModel.BROADCASTING); 定时消息 生产者 12// This message will be delivered to consumer 10 seconds later. message.setDelayTimeLevel(3); 消费者消费者监听器中可以取得消息的存储时间，进而可以计算出延迟的时间 12345for (MessageExt message : messages) &#123; // Print approximate delay time period System.out.println("Receive message[msgId=" + message.getMsgId() + "] " + (System.currentTimeMillis() - message.getStoreTimestamp()) + "ms later"); &#125; 批量处理 能够提高小的消息的传送效率 限制1：same topic, same waitStoreMsgOK and no schedule support. 限制2：the total size of the messages in one batch should be no more than 1MiB. 1234567891011String topic = "BatchTest";List&lt;Message&gt; messages = new ArrayList&lt;&gt;();messages.add(new Message(topic, "TagA", "OrderID001", "Hello world 0".getBytes()));messages.add(new Message(topic, "TagA", "OrderID002", "Hello world 1".getBytes()));messages.add(new Message(topic, "TagA", "OrderID003", "Hello world 2".getBytes()));try &#123; producer.send(messages);&#125; catch (Exception e) &#123; e.printStackTrace(); //handle the error&#125; 太大则需要分块生产 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class ListSplitter implements Iterator&lt;List&lt;Message&gt;&gt; &#123; private final int SIZE_LIMIT = 1000 * 1000; private final List&lt;Message&gt; messages; private int currIndex; public ListSplitter(List&lt;Message&gt; messages) &#123; this.messages = messages; &#125; @Override public boolean hasNext() &#123; return currIndex &lt; messages.size(); &#125; @Override public List&lt;Message&gt; next() &#123; int nextIndex = currIndex; int totalSize = 0; for (; nextIndex &lt; messages.size(); nextIndex++) &#123; Message message = messages.get(nextIndex); int tmpSize = message.getTopic().length() + message.getBody().length; Map&lt;String, String&gt; properties = message.getProperties(); for (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123; tmpSize += entry.getKey().length() + entry.getValue().length(); &#125; tmpSize = tmpSize + 20; //for log overhead if (tmpSize &gt; SIZE_LIMIT) &#123; //it is unexpected that single message exceeds the SIZE_LIMIT //here just let it go, otherwise it will block the splitting process这里直接让这个单独的“大”消息过去，否则会阻塞拆分的进程 if (nextIndex - currIndex == 0) &#123; //if the next sublist has no element, add this one and then break, otherwise just break如果下个子列表没有元素，则把这个“大”消息加进去，并把nextIndex+1 nextIndex++; &#125; break; &#125; if (tmpSize + totalSize &gt; SIZE_LIMIT) &#123; break; &#125; else &#123; totalSize += tmpSize; &#125; &#125; List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex); currIndex = nextIndex; return subList; &#125;&#125;//then you could split the large list into small ones:ListSplitter splitter = new ListSplitter(messages);while (splitter.hasNext()) &#123; try &#123; List&lt;Message&gt; listItem = splitter.next(); producer.send(listItem); &#125; catch (Exception e) &#123; e.printStackTrace(); //handle the error &#125;&#125; 消息过滤选择 一条消息只能有一个tag，因此通过consumer.subscribe(“TOPIC”, “TAGA || TAGB || TAGC”);这种方式的选择性不强 可以通过向message中添加1到n条属性，消费者对属性或属性组合进行逻辑判断来过滤消息 1234// 生产者Set some properties.msg.putUserProperty("a", String.valueOf(i));//消费者consumer.subscribe("TopicTest", MessageSelector.bySql("a between 0 and 3"); OpenMessaging国际标准OpenMessaging 新闻 Logappender日志Transaction事务处理]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java socket编程]]></title>
    <url>%2FJava%2FSocket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[传统阻塞方式直接上代码 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MyClient &#123; String host; int port; Socket socket; int timeOut=10000; BufferedReader bufferedReader; PrintStream printStream; BufferedReader receive; public MyClient(String host, int port) &#123; this.host = host; this.port = port; try &#123; socket=new Socket(host,port); socket.setSoTimeout(timeOut);//设置接收响应的超时时间 bufferedReader=new BufferedReader(new InputStreamReader(System.in));//用户输入 printStream=new PrintStream(socket.getOutputStream());//响应流 receive=new BufferedReader(new InputStreamReader(socket.getInputStream()));//响应流 &#125;catch (Exception e)&#123; &#125; &#125;&lt;!--more--&gt; public void sendAndReceive() throws Exception&#123; boolean bye=false; String message; while (!bye)&#123; System.out.println("input your message..."); message=bufferedReader.readLine(); if(message.equals("")||message.isEmpty()) break; if(message.equals("bye")) bye=true; printStream.println(message); try&#123; message=receive.readLine(); System.out.println("receive:"+message); &#125;catch (Exception e)&#123; System.out.println("response timeout"); break; &#125; &#125; printStream.close(); try &#123; socket.close(); &#125;catch (Exception e)&#123;&#125; &#125; public static void main(String[] args)&#123; MyClient myClient=new MyClient("127.0.0.1",8085); //MyClient myClient2=new MyClient("127.0.0.1",8085); try &#123; myClient.sendAndReceive(); //myClient2.sendAndReceive(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 服务端线程 12345678910111213141516171819202122232425262728293031323334public class MyServerThread implements Runnable&#123; Socket client; BufferedReader req; String reqMsg; PrintStream out; public MyServerThread(Socket client) &#123; this.client = client; &#125; @Override public void run() &#123; boolean endFlag=true; while (endFlag)&#123; try &#123; req=new BufferedReader(new InputStreamReader(client.getInputStream())); reqMsg=req.readLine(); if(reqMsg==null||reqMsg.equals("bye")) endFlag=false; out=new PrintStream(client.getOutputStream()); out.println("server resp:"+reqMsg); &#125; catch (IOException e) &#123; e.printStackTrace(); endFlag=false; &#125; &#125; out.close(); try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 服务端 1234567891011121314public class MyServer &#123; public static void main(String[] args) &#123; Socket client; try &#123; ServerSocket serversocket = new ServerSocket(8085); while (true)&#123; client=serversocket.accept(); new Thread(new MyServerThread(client)).start(); &#125; &#125;catch (Exception e)&#123; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM2]]></title>
    <url>%2FJava%2FJVM2%2F</url>
    <content type="text"><![CDATA[常用java命令 jps——查看进程信息jps [options] 第一列是VMpid，第二列class或jar的名称 hostid指定主机，不写为当前机器，格式 [protocol:]&lt;&lt;//&gt;hostname&gt;&lt;:port&gt; q：仅仅显示pid；-m:输出主函数传入的参数；-l: 输出应用程序主类完整package名称或jar完整名称；-v: 列出jvm参数；-V: 输出通过.hotsportrc或-XX:Flags=指定的jvm参数 2.jstatjstat [options] pid12345678910111213options: -class (类加载器) -compiler (JIT) -gc (GC堆状态) -gccapacity (各区大小) -gccause (最近一次GC统计和原因) -gcnew (新区统计) -gcnewcapacity (新区大小) -gcold (老区统计) -gcoldcapacity (老区大小) -gcpermcapacity (永久区大小) -gcutil (GC统计汇总) -printcompilation (HotSpot编译统计) jstack——查看线程信息jstack pid 将占用cpu或其他资源多的pid找出来(可以通过top命令)，然后转成16进制的数，即为nid，找到对应得线程，线程状态有runnable、blocked和waiting，可以查看线程的调用栈JVM参数配置分析 配置文件位置：eclipse.ini、TOMCAT_HOME/bin/catalina.sh（.bat）、idea有-vm option]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet和Sping过滤器]]></title>
    <url>%2FSpring%2FSping%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Servlet容器与TomcatTomcat 的容器等级中，Context 容器是直接管理 Servlet 在容器中的包装类 Wrapper，所以 Context 容器如何运行将直接影响 Servlet 的工作方式（一个 Context容器对应一个 Web 应用（工程），也就是Servlet 运行时的 Servlet 容器）。 Tomcat 的配置文件中配置应用 12&lt;Context path="/projectOne " docBase="D:\projects\projectOne"reloadable="true" /&gt; tomcat添加一个应用 1234567Tomcat tomcat = getTomcatInstance(); File appDir = new File(getBuildDirectory(), "webapps/examples"); tomcat.addWebapp(null, "/examples", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = getUrl("http://localhost:" + getPort() + "/examples/servlets/servlet/HelloWorldExample"); assertTrue(res.toString().indexOf("&lt;h1&gt;Hello World!&lt;/h1&gt;") &gt; 0); 123456789101112131415161718192021//Tomcat.addWebapppublic Context addWebapp(Host host, String url, String path) &#123; silence(url); Context ctx = new StandardContext();//创建一个容器 ctx.setPath( url );//访问地址，和配置文件中一致 ctx.setDocBase(path);//实际地址，和配置文件中一致 if (defaultRealm == null) &#123; initSimpleAuth(); &#125; ctx.setRealm(defaultRealm); ctx.addLifecycleListener(new DefaultWebXmlListener()); ContextConfig ctxCfg = new ContextConfig();//这个类将会负责整个 Web 应用配置的解析工作 ctx.addLifecycleListener(ctxCfg); ctxCfg.setDefaultWebXml("org/apache/catalin/startup/NO_DEFAULT_XML"); if (host == null) &#123; getHost().addChild(ctx); &#125; else &#123; host.addChild(ctx); &#125; return ctx; &#125; Tomcat 的启动逻辑是基于观察者模式设计的，所有的容器都会继承 Lifecycle 接口，它管理者容器的整个生命周期，所有容器的的修改和状态的改变都会由它去通知已经注册的观察者原文链接 Servlet servlet容器负责加载和实例化Servlet，在容器启动时根据设置决定是在启动时初始化（loadOnStartup大于等于0，值越小优先级越高），还是延迟初始化直到第一次请求前 init()方法执行一次性的动作，可以通过ServletConfig配置对象，获取初始化参数，访问ServletContext上下文环境 配置：1.通过@WebServlet的initParams属性来指定。2.通过在web.xml文件中配置 Servlet默认是线程不安全的，单例多线程，一个容器中只有每个servlet一个实例。StandardWrapper负责Servlet的创建，其中SingleThreadModule模式下创建的实例数不能超过20个，也就是同时只能支持20个线程访问这个Serlvet。 Servlet多线程机制背后有一个线程池在支持，线程池在初始化初期就创建了一定数量的线程对象，通过提高对这些对象的利用率，避免高频率地创建对象，从而达到提高程序的效率的目的。Spring过滤器用来实现一些特殊的功能。例如URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等。常见的有CharacterEncodingFilter、InvilidCharacterFilter(防止脚本攻击)等。具体步骤 编写Filter12345678910111213141516171819public class FilterTest implements Filter&#123; public void destroy() &#123; System.out.println("----Filter销毁----"); &#125; public void doFilter(ServletRequest request, ServletResponse response,FilterChain filterChain) throws IOException, ServletException &#123; // 对request、response进行一些预处理 request.setCharacterEncoding("UTF-8"); response.setCharacterEncoding("UTF-8"); response.setContentType("text/html;charset=UTF-8"); System.out.println("----调用service之前执行一段代码----"); filterChain.doFilter(request, response); // 执行目标资源，放行 System.out.println("----调用service之后执行一段代码----"); &#125; public void init(FilterConfig arg0) throws ServletException &#123; System.out.println("----Filter初始化----"); &#125;&#125; FilterConfig(init()方法的入参)获取配置的初始化参数 1234 String getFilterName()：得到filter的名称。 String getInitParameter(String name)： 返回在部署描述中指定名称的初始化参数的值。如果不存在返回null. Enumeration getInitParameterNames()：返回过滤器的所有初始化参数的名字的枚举集合。 public ServletContext getServletContext()：返回Servlet上下文对象的引用。 FilterChainweb服务器将Filter组合起来形成为一个Filter链。根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。 注册12345678910111213141516171819&lt;web-app ...&gt; ... &lt;!--配置过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;FilterTest&lt;/filter-name&gt; &lt;filter-class&gt;com.freaxjj.filter.FilterTest&lt;/filter-class&gt; [&lt;init-param&gt; &lt;description&gt;配置FilterTest过滤器的初始化参数&lt;/description&gt; &lt;param-name&gt;like&lt;/param-name&gt; &lt;param-value&gt;java&lt;/param-value&gt; &lt;/init-param&gt;] &lt;/filter&gt; &lt;!--映射过滤器--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterTest&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; [&lt;servlet-name&gt;、&lt;dispatcher&gt;] &lt;/filter-mapping&gt;&lt;/web-app&gt; 指定过滤器所拦截的Servlet名称。 指定过滤器所拦截的资源被 Servlet 容器调用的方式。默认子元素REQUEST。用户可以设置多个子元素用来指定 Filter 对资源的多种调用方式进行拦截 REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。 INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。 FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。 ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。实践12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class SelfDefineInvalidCharacterFilter implements Filter&#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException &#123; String parameterName = null; String parameterValue = null; // 获取请求的参数 @SuppressWarnings("unchecked") Enumeration&lt;String&gt; allParameter = request.getParameterNames(); while(allParameter.hasMoreElements())&#123; parameterName = allParameter.nextElement(); parameterValue = request.getParameter(parameterName); if(null != parameterValue)&#123; for(String str : invalidCharacter)&#123; if (StringUtils.containsIgnoreCase(parameterValue, str))&#123; request.setAttribute("errorMessage", "非法字符：" + str); RequestDispatcher requestDispatcher = request.getRequestDispatcher("/error.jsp"); requestDispatcher.forward(request, response); return; &#125; &#125; &#125; &#125; filterChain.doFilter(request, response); // 执行目标资源，放行 &#125; public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; // 需要过滤的非法字符 private static String[] invalidCharacter = new String[]&#123; "script","select","insert","document","window","function", "delete","update","prompt","alert","create","alter", "drop","iframe","link","where","replace","function","onabort", "onactivate","onafterprint","onafterupdate","onbeforeactivate", "onbeforecopy","onbeforecut","onbeforedeactivateonfocus", "onkeydown","onkeypress","onkeyup","onload", "expression","applet","layer","ilayeditfocus","onbeforepaste", "onbeforeprint","onbeforeunload","onbeforeupdate", "onblur","onbounce","oncellchange","oncontextmenu", "oncontrolselect","oncopy","oncut","ondataavailable", "ondatasetchanged","ondatasetcomplete","ondeactivate", "ondrag","ondrop","onerror","onfilterchange","onfinish","onhelp", "onlayoutcomplete","onlosecapture","onmouse","ote", "onpropertychange","onreadystatechange","onreset","onresize", "onresizeend","onresizestart","onrow","onscroll", "onselect","onstaronsubmit","onunload","IMgsrc","infarction" &#125;; &#125; 生命周期Filter的创建和销毁由web服务器负责。 web应用程序启动时，web服务器将创建Filter的实例对象，并调用其init方法。filter对象只会创建一次。init方法和destroy方法在Filter的生命周期中仅执行一次。在destroy方法中，可以释放过滤器使用的资源。 原文链接]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解]]></title>
    <url>%2FSpring%2FSpring%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[spring中文文档 感谢！ 注解获取容器(上下文)123456public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig. class); MyService myService = ctx.getBean(MyService.class); myService.doStuff();&#125; 通用 @Scope注解定义该bean的作用域范围，注解方式如@scope(“prototype”),配置方式. singleton,容器内只有一个实例，或@Singleton prototype,原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例 request,每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，配置： 1234567 &lt;web-app&gt; ... &lt;listener&gt;&lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; ...&lt;/web-app&gt; session，配置同上，每次HTTP Session都会产生一个新的bean，同时该bean仅在当前HTTP session内有效 global session Bean注解主要用于方法上，有点类似于工厂方法 1234567@Configurationpublic class AppConfig &#123; @Bean public MyService myService() &#123; return new MyServiceImpl(); &#125;&#125; 和下面的配置类似123&lt;beans&gt; &lt;bean id="myService" class="com.acme.services.MyServiceImpl"/&gt;&lt;/beans&gt; @AutoWired和@Resource(J2EE注解) @Autowired注解默认按照类型装配，如果容器中包含多个同一类型的Bean，那么启动容器时会报找不到指定类型bean的异常，解决办法是结合@Qualified注解进行限定，指定注入的bean名称。 @Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。控制器注解@Controller @RestController,@RestController注解相当于@ResponseBody ＋ @Controller 如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。 如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。 如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。 @ModelAttribute @RequestMapping 既可以作用在类级别，也可以作用在方法级别。如果没有指定method，表示都可以接收。(还有变体@GetMapping和@PostMapping) @RequestParam用于方法入参，@RequestParam(value = “name”, required = false) String name,required默认为true，必传 @PathVariable,绑定url到参数上，支持正则 方法增加入参ModelMap modelMap，spring会创建实例，modelMap.put()可以用来向页面返回数据 1234@RequestMapping(value="/happy/&#123;dayid&#125;",method=RequestMethod.GET)public String findPet(@PathVariable String dayid, Model mode) &#123;//使用@PathVariable注解绑定 &#123;dayid&#125; 到String dayid&#125; @RequestBody是指方法参数应该被绑定到HTTP请求Body上。 @ResponseBody的作用是将返回类型直接输入到HTTP response body中，常用来输出JSON数据。 @Component与@Configuration1234567891011121314151617181920212223242526272829@Configurationpublic static class Config &#123; @Bean public SimpleBean simpleBean() &#123; return new SimpleBean(); &#125; @Bean public SimpleBeanConsumer simpleBeanConsumer() &#123; return new SimpleBeanConsumer(simpleBean()); &#125;&#125;//@Component则需要这样写，否则就将有两个SimpleBean实例@Componentpublic static class Config &#123; @Autowired SimpleBean simpleBean; @Bean public SimpleBean simpleBean() &#123; return new SimpleBean(); &#125; @Bean public SimpleBeanConsumer simpleBeanConsumer() &#123; return new SimpleBeanConsumer(simpleBean); &#125;&#125; 校验 @Valid (在Controller响应方法的form对应实体入参上加入@Valid注解，在form对应实体的字段上添加@NotNull等注解)12345678910111213141516@Null 限制只能为null @NotNull 限制必须不为null @AssertFalse 限制必须为false @AssertTrue 限制必须为true @DecimalMax(value) 限制必须为一个不大于指定值的数字 @DecimalMin(value) 限制必须为一个不小于指定值的数字 @Digits(integer,fraction) 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction @Future 限制必须是一个将来的日期 @Max(value) 限制必须为一个不大于指定值的数字 @Min(value) 限制必须为一个不小于指定值的数字 @Pattern(value) 限制必须符合指定的正则表达式 @Size(max,min) 限制字符长度必须在min到max之间 @Past 验证注解的元素值（日期类型）比当前时间早 @NotEmpty 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0） @NotBlank 验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格 @Email 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 eg.123456@ResponseBody @PostMapping(value="/add") public String add(@Valid Student student,BindingResult bindingResult)&#123; if(bindingResult.hasErrors())&#123; ..... &#125; 123456789101112131415@Entity@Table(name="t_student")public class Student &#123; @Id @GeneratedValue private Integer id; @NotEmpty(message="姓名不能为空！") @Column(length=50) private String name; @NotNull(message="年龄不能为空！") @Min(value=18,message="年龄必须大于18岁！") @Column(length=50) private Integer age; 其他注解 @PostConstruct 和 @PreDestroy 方法 实现初始化和销毁bean之前进行的操作 lombok注解：可以不用生成get、set和构造方法，idea中安装lombok-plugin插件，另外勾选enable annotation processing1234@Getter@Setter@NoArgsConstructor@AllArgsConstructor 事务 开启事务注解&lt;tx:annotation-driven transaction-manager=”transactionManager” /&gt;,用@Transactional 1234567891011121314//删除失败后回滚@Servicepublic class CompanyServiceImpl implements CompanyService &#123; @Autowired private CompanyDAO companyDAO; //设置传播、只读属性和回滚策略，回滚可定义其他异常，isolation定义隔离级别，timeout设置超时时间(s) @Transactional(propagation = Propagation.REQUIRED, readOnly = false, rollbackFor = Exception.class) public int deleteByName(String name) &#123; int result = companyDAO.deleteByName(name); return company; &#125; ...&#125; 传播级别 | 事务传播行为类型 | 说明 || ————————- | ———————————————————— || PROPAGATION_REQUIRED | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 || PROPAGATION_SUPPORTS | 支持当前事务，如果当前没有事务，就以非事务方式执行。 || PROPAGATION_MANDATORY | 使用当前的事务，如果当前没有事务，就抛出异常。 || PROPAGATION_REQUIRES_NEW | 新建事务，如果当前存在事务，把当前事务挂起。 || PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 || PROPAGATION_NEVER | 以非事务方式执行，如果当前存在事务，则抛出异常 || PROPAGATION_NESTED | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类 似的操作 | 隔离级别 | 类型 | 说明 || ——————- | ————————————————– || DEFAULT | 采用数据库默认隔离级别 || READ_UNCOMMITTED | 读未提交的数据（会出现脏读取） || READ_COMMITTED | 读已提交的数据（会出现幻读，即前后两次读的不一样） || REPEATABLE_READ | 可重复读，会出现幻读 || SERIALIZABLE 串行化 | （对资源消耗较大，一般不使用） |]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发2]]></title>
    <url>%2FJava%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[线程同步的方法同步是一种高开销的操作，因此应该尽量减少同步的内容。 synchronized可以用在方法或者代码块(颗粒更细一点)上 volatile用在变量上，不能用在final类型的变量，使用volatile修饰相当于告诉虚拟机该域可能会被其他线程更新， 因此每次使用该变量都要去主存获取，而不是使用缓存中的值，不提供原子操作 可重入锁ReentrantLock 使用局部变量 ThreadLocal，每个线程都有自己的副本 1234new ThreadLocal(T) : 创建一个线程本地变量 get() : 返回此线程局部变量的当前线程副本中的值 initialValue() : 返回此线程局部变量的当前线程的"初始值" set(T value) : 将此线程局部变量的当前线程副本中的值设置为value 阻塞队列LinkedBlockingQueue，公用一个队列 1234LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue put(E e) : 在队尾添加一个元素，如果队列满则阻塞 size() : 返回队列中的元素个数 take() : 移除并返回队头元素，如果队列空则阻塞 使用原子型变量，如AtomicInteger(util.concurrent.atomic) 可重入锁ReentrantLock是可重入、互斥、实现了Lock接口的锁常用方法 ReentrantLock() : 创建一个ReentrantLock实例 lock() : 获得锁 unlock() : 释放锁12345678910111213141516class Bank &#123; private int account = 100; //创建锁 private Lock lock = new ReentrantLock(); public int getAccount() &#123; return account; &#125; public void save(int money) &#123; lock.lock();//加锁 try&#123; account += money; &#125;finally&#123; lock.unlock();//解锁 &#125; &#125; ｝ synchronized synchronized可以用在方法或者代码块(颗粒更细一点)上如果是synchronized(this){}，那么其他线程执行到同个对象的这段代码，必须要等持有对象锁的线程执行完才有机会；如果要锁住代码要通过synchronized(类名.class){}，这样如果就算是不同对象执行到这边也是要等待锁的 synchronized如果用在静态方法上锁住的也是这段代码块Runnable和Thread的区别 1234- Runnable是接口，定义了一个抽象的run()方法。这个方法会在线程执行时被调用。- Thread是类，实现了Runnable接口。类只能单继承，如果要继承其他类就需要自己实现Runnable接口。- 启动线程必须要通过start()方法（调用的native非java代码）,因此如果实现了Runable接口的可以构造Thread，而不能通过run()，否则只是调用了一个普通方法而已。- 如果用一个Runnable对象构造了多个线程，多个线程都start()起来,Runnable对象的属性都是共享的，相当于多个线程共同做一件事。 wait()和sleep的区别最大区别，wait()会释放锁，在被唤醒后再申请锁，而sleep是在synchronized中，不会释放锁123 sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会; sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。 在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 123wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问； wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。 wiat()必须放在synchronized中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。 Future模式Future模式是多线程开发中非常常见的一种设计模式。它的核心思想是异步调用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//返回客户端的立即凭据public class FutureData&lt;T&gt; &#123; Object data;//处理结果 boolean isReady;//是否处理完毕标志 //由处理线程处理完写入 public synchronized void setData(Object data)&#123; this.data=data; isReady=true; notifyAll(); &#125; //由客户端通过凭据获取 public synchronized Object getData()&#123; while (!isReady)&#123; try&#123; wait(); &#125;catch (Exception e)&#123; &#125; &#125; return data; &#125;&#125;//服务端public class Server &#123; final FutureData&lt;String&gt; returnFirst=new FutureData&lt;&gt;(); public FutureData&lt;String&gt; handleReq()&#123; //创建一个线程处理请求，就返回凭据 new Thread(new Runnable()&#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125;catch (Exception e)&#123;&#125; returnFirst.setData("绝密文件"); &#125; &#125;).start(); return returnFirst; &#125;&#125;//调用 Server server=new Server(); FutureData&lt;String&gt; returnData=server.handleReq(); String doElse=" ";//做其他的事情 System.out.println(returnData.getData());]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程]]></title>
    <url>%2FJava%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[关于并发1数据副本是避免共享数据的好方法，复制出来的对象只是以只读的方式对待。Java 5的java.util.concurrent包中增加一个名为CopyOnWriteArrayList的类，它是List接口的子类型，所以你可以认为它是ArrayList的线程安全的版本，它使用了**写时复制**的方式创建数据副本进行操作来避免对共享数据并发访问而引发的问题。 1**Servlet**就是以单实例多线程的方式工作，和每个请求相关的数据都是通过Servlet子类的service方法（或者是doGet或doPost方法）的参数传入的。只要Servlet中的代码只使用局部变量，Servlet就不会导致同步问题。**Spring MVC**的控制器也是这么做的，从请求中获得的对象都是以方法的参数传入而不是作为类的成员，很明显Struts 2的做法就正好相反，因此Struts 2中作为控制器的Action类都是每个请求对应一个实例 123 在Java 5以前，可以用**synchronized**关键字来实现锁的功能，对于类的非静态方法（成员方法）而言，这意味这要取得对象实例的锁，对于类的静态方法（类方法）而言，要取得类的Class对象的锁，对于同步代码块，程序员可以指定要取得的是那个对象的锁。 在JVM内部，为了提高效率，同时运行的每个线程都会有它正在处理的数据的缓存副本，简单的说就是在同步块或同步方法执行完后，对被锁定的对象做的任何修改要在释放锁之前写回到主内存中；在进入同步块得到锁之后，被锁定对象的数据是从主内存中读出来的，持有锁的线程的数据副本一定和主内存中的数据视图是同步的 。 不管是同步代码块还是同步方法，每次只有一个线程可以进入，如果其他线程试图进入（不管是同一同步块还是不同的同步块），JVM会将它们挂起（放入到等锁池中）。这种结构在并发理论中称为临界区（critical section）。这里我们可以对Java中用synchronized实现同步和锁的功能做一个总结： 只能锁定对象，不能锁定基本数据类型 被锁定的对象数组中的单个对象不会被锁定 同步方法可以视为包含整个方法的synchronized(this) { … }代码块 静态同步方法会锁定它的Class对象 内部类的同步是独立于外部类的 synchronized修饰符并不是方法签名的组成部分，所以不能出现在接口的方法声明中 非同步的方法不关心锁的状态，它们在同步方法运行时仍然可以得以运行 synchronized实现的锁是可重入的锁。 线程要么得到锁，要么阻塞，没有其他的可能性 volatile：变量的值在使用之前总会从主内存中再读取出来。对变量值的修改总会在完成之后写回到主内存中。保证数据可见性 多线程的实现方式123456789101112131415161718192021222324252627282930313233343536373839继承自Thread类(不能线程共享)实现Runnable接口(不可以返回值)实现Callable接口(可以抛出异常、返回值)ThreadPoolExecutor ThreadPoolExecutor的策略 线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务 线程数量达到了corePools，则将任务移入队列等待 队列已满，新建线程(非核心线程)执行任务 队列已满，总线程数又达到了maximumPoolSize,就会(RejectedExecutionHandler)抛出异常 常见四种线程池 CachedThreadPool:线程数无限制;有空闲线程则复用空闲线程，若无空闲线程则新建线程;一定程序减少频繁创建/销毁线程，减少系统开销. FixedThreadPool:可控制线程最大并发数（同时执行的线程数）;超出的线程会在队列中等待 ScheduledThreadPool:支持定时及周期性任务执行。 SingleThreadExecutor:有且仅有一个工作线程执行任务;所有任务按照指定顺序执行，即遵循队列的入队出队规则Executors线程同步同步方法:同步代码块:synchronized 关键字在编译之后会在同步块的前后加上monitorenter和monitorexit,在执行monitorenter时，需要获取锁，如果占用所得对象是自己则需要将锁计数器加1,monitorexit时将锁计数器减1，如果为0则释放锁关键字volatile: 防止指令重排 编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序； 处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序； 实现可见性,不保证原子性 可见性：volatile保证线程所在空间中的volatile修饰的变量的值是最新的; 不保证原子性:两个线程对volatile修饰的变量同时进行赋值操作，可能导致两个线程对该变量进行一次赋值。Reentrantlock:可重入锁,synchronized和Reentrantlock都是重入锁，区别如下: synchronized: 依赖JVM实现，加入偏向锁之后性能和Reentrantlock差不多了； 使用比较方便简洁，由编译器去实现加锁和释放； 只能是非公平锁； Reentrantlock: 主要依赖代码控制实现，可以避免进入内核态的阻塞； 需要手动加锁和释放锁，容易由于忘记释放锁导致死锁； 既可以是公平锁也可以是非公平锁； 提供Condition类，可以分组唤醒线程； 能够中断等待线程；使用局部变量实现线程的同步，如:ThreadLocal。 并发集合类123456789Java 5以后出现的并发集合类就是专门针对普通集合出现不能并发和不能在迭代过程中修改数据等问题而出现的。主要有：**ConcurrentHashMap**（替代hashtable）; ConcurrentSkipListMap; ConCurrentSkipListSet; **CopyOnWriteArrayList**（是ArrayList 的一个线程安全的变形，其中所有可变操作（添加、设置，等等）都是通过对基础数组进行一次新的复制来实现的。这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效；自创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。不支持迭代器上更改元素的操作（移除、设置和添加）。）;CopyOnWriteArraySet; ConcurrentLinkedQueue（此队列按照 FIFO原则对元素进行排序，队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。不允许 null 元素。 ）;​` `]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2FJava%2FJVM%2F</url>
    <content type="text"><![CDATA[JVM 体系： 类的加载机制 jvm内存结构 GC算法 垃圾回收 GC分析 命令调优 加载 类的生命周期： 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用 初始化，为类的静态变量赋予正确的初始值 使用，new出对象程序中使用 卸载，执行垃圾回收 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。 启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器 内存 Java堆（Heap、GC堆）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。堆由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配 初级回收将年轻代分为三个区域, 一个新生代 , 2个大小相同的复活代, 应用程序只能使用一个新生代和一个复活代, 当发生初级垃圾回收的时候,gc挂起程序, 然后将新生代和复活代中的存活对象复制到另外一个非活动的复活代中,然后一次性清除新生代和复活代，将原来的非复活代标记成为活动复活代。将在指定次数回收后仍然存在的对象移动到老年代中，初级回收后，得到一个空的可用的新生代。(参考文章：[JVM内存：年轻代，老年代，永久代][https://blog.csdn.net/sted_zxz/article/details/72476673]) 方法区（Method Area，永久代）,方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。 JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。 12345678910111213141516控制参数-Xms设置堆的最小空间大小。-Xmx设置堆的最大空间大小。-XX:NewSize设置新生代最小空间大小。-XX:MaxNewSize设置新生代最大空间大小。-XX:PermSize设置永久代最小空间大小。-XX:MaxPermSize设置永久代最大空间大小。-Xss设置每个线程的堆栈大小。如果没有直接设置老年代的参数，老年代空间大小=堆空间大小-年轻代大空间大小 垃圾回收 判断对象是否存活一般有两种方式： 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。 GC算法 GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。 PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数 调优 调优命令 Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 jmap，JVM Memory Map命令用于生成heap dump文件 jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 jstack，用于生成java虚拟机当前时刻的线程快照。 jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。 调优工具 常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。 jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控 jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。 MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗 GChisto，一款专业分析gc日志的工具]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sql 注入基础原理介绍]]></title>
    <url>%2Fsql%2Fsql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[一、实验说明1.1 实验内容SQL注入攻击通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，本章课程通过 LAMP 搭建 Sql 注入环境，两个实验分别介绍 Sql 注入爆破数据库、Sql 注入绕过验证两个知识点。1.2 实验知识点Sql 注入漏洞的原理Sql 注入点的判断方法Sql 注入漏洞的分类 1.3 实验环境python2.7Xfce 终端Firefox 浏览器 1.4 适合人群本课程难度为简单，属于初级级别课程，适合具有一点 sql 语法基础的用户。如果你没有 sql 的基础，建议你先阅读下述内容：Mysql 入门教程 或学习以下免费课程：MySQL 基础课程 1.5 代码获取你可以通过下面命令将代码下载到实验楼环境中，作为参照对比进行学习。$ wget http://labfile.oss.aliyuncs.com/courses/876/dvwa.tar.gz$ wget http://labfile.oss.aliyuncs.com/courses/876/sql2.tar.gz 二、实验原理Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。本课程将带你从介绍 Web 应用运行原理开始，一步一步理解 Sql 注入的由来、原理和攻击方式。三、Web 程序三层架构三层架构(3-tier architecture) 通常意义上就是将整个业务应用划分为：界面层（User Interface layer） 业务逻辑层（Business Logic Layer） 数据访问层（Data access layer）。 区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构被应用于众多类型的软件开发。由数据库驱动的Web应用程序依从三层架构的思想也分为了三层：表示层。 业务逻辑层（又称领域层） 数据访问层（又称存储层） 拓扑结构如下图所示在上图中，用户访问实验楼主页进行了如下过程：在 Web 浏览器中输入 www.shiyanlou.com 连接到实验楼服务器。 业务逻辑层的 Web 服务器从本地存储中加载 index.php 脚本并解析。 脚本连接位于数据访问层的 DBMS（数据库管理系统），并执行 Sql 语句。 数据访问层的数据库管理系统返回 Sql 语句执行结果给 Web 服务器。 业务逻辑层的 Web 服务器将 Web 页面封装成 HTML 格式发送给表示层的 Web 浏览器。 表示层的 Web 浏览器解析 HTML 文件，将内容展示给用户。 在三层架构中，所有通信都必须要经过中间层，简单地说，三层架构是一种线性关系。四、Sql 注入漏洞4.1 Sql 注入产生原因及威胁：刚刚讲过当我们访问动态网页时, Web 服务器会向数据访问层发起 Sql 查询请求，如果权限验证通过就会执行 Sql 语句。这种网站内部直接发送的Sql请求一般不会有危险，但实际情况是很多时候需要结合用户的输入数据动态构造 Sql 语句，如果用户输入的数据被构造成恶意 Sql 代码，Web 应用又未对动态构造的 Sql 语句使用的参数进行审查，则会带来意想不到的危险。Sql 注入带来的威胁主要有如下几点猜解后台数据库，这是利用最多的方式，盗取网站的敏感信息。绕过认证，列如绕过验证登录网站后台。注入可以借助数据库的存储过程进行提权等操作 4.2 Sql 注入示例一.猜解数据库接下来我们通过一个实例，让你更加清楚的理解 Sql 注入猜解数据库是如何发生的。如下图所示，先下载文件并解压运行：shiyanlou:~/ $ wget http://labfile.oss.aliyuncs.com/courses/876/dvwa.tar.gzshiyanlou:~/ $ tar -zxvf dvwa.tar.gzshiyanlou:~/ $ cd dvwashiyanlou:~/ $ sudo apt-get updateshiyanlou:~/ $ ./deploy.sh 进入 Firefox 浏览器，输入网址 : localhost/dvwasql , 点击create/Reset Database创建数据库：[图片上传中。。。（2）]进入登录界面，默认用户名为 admin 密码为 password 将 Security 级别调整为 low (有兴趣的同学可以看看其他级别，这里只做入门讲解)进入 SQL injection页面开始注入：先输入 1 ，查看回显 (URL中ID=1，说明php页面通过get方法传递参数)：那实际上后台执行了什么样的Sql语句呢？点击 view source查看源代码 ：可以看到，实际执行的Sql语句是：SELECT first_name, last_name FROM users WHERE user_id = ‘1’; 我们是通过控制参数Id的值来返回我们需要的信息。如果我们不按常理出牌，比如在输入框中输入 1’ order by 1# 实际执行的Sql语句就会变成:SELECT first_name, last_name FROM users WHERE user_id = ‘1’ order by 1#`;(按照Mysql语法，#后面会被注释掉，使用这种方法屏蔽掉后面的单引号，避免语法错误) 这条语句的意思是查询users表中user_id为1的数据并按第一字段排行。输入 1’ order by 1#和 1’ order by 2#时都返回正常：当输入 1’ order by 3#时，返回错误：[图片上传中。。。（11）]由此可知，users表中只有两个字段，数据为两列。接下来我们使用 union select联合查询继续获取信息。union 运算符可以将两个或两个以上 select 语句的查询结果集合合并成一个结果集合显示，即执行联合查询。需要注意在使用 union 查询的时候需要和主查询的列数相同，而我们之前已经知道了主查询列数为 2，接下来就好办了。输入1’ union select database(),user()#进行查询 ：database()将会返回当前网站所使用的数据库名字.user()将会返回执行当前查询的用户名. 实际执行的Sql语句是 :SELECT first_name, last_name FROM users WHERE user_id = ‘1’ union select database(),user()#`; [图片上传中。。。（12）]通过上图返回信息，我们成功获取到：当前网站使用数据库为 dvwa .当前执行查询用户名为 root@localhost . 同理我们再输入 1’ union select version(),@@version_compile_os#进行查询：version() 获取当前数据库版本.@@version_compile_os 获取当前操作系统。 实际执行的Sql语句是:SELECT first_name, last_name FROM users WHERE user_id = ‘1’ union select version(),@@version_compile_os#`; [图片上传中。。。（13）]通过上图返回信息，我们又成功获取到：当前数据库版本为 : 5.6.31-0ubuntu0.15.10.1.当前操作系统为 : debian-linux-gnu 接下来我们尝试获取 dvwa 数据库中的表名。information_schema 是 mysql 自带的一张表，这张数据表保存了 Mysql 服务器所有数据库的信息,如数据库名，数据库的表，表栏的数据类型与访问权限等。该数据库拥有一个名为 tables 的数据表，该表包含两个字段 table_name 和 table_schema，分别记录 DBMS 中的存储的表名和表名所在的数据库。我们输入1’ union select table_name,table_schema from information_schema.tables where table_schema= ‘dvwa’#进行查询：实际执行的Sql语句是：SELECT first_name, last_name FROM users WHERE user_id = ‘1’ union select table_name,table_schema from information_schema.tables where table_schema= ‘dvwa’#`; [图片上传中。。。（14）]通过上图返回信息，我们再获取到：dvwa 数据库有两个数据表，分别是 guestbook 和 users . 有些同学肯定还不满足目前获取到的信息，那么我们接下来尝试获取重量级的用户名、密码。由经验我们可以大胆猜测users表的字段为 user 和 password ，所以输入：1’ union select user,password from users#进行查询：实际执行的 Sql 语句是：SELECT first_name, last_name FROM users WHERE user_id = ‘1’ union select user,password from users#`; [图片上传中。。。（15）]可以看到成功爆出用户名、密码，密码采用 md5 进行加密，可以到www.cmd5.com进行解密。直此，同学们应该已经对 Sql 注入有了一个大概得了解，也清楚了 Sql 注入的强大。4.3 Sql 注入实例二.验证绕过接下来我们再试试另一个利用 Sql 漏洞绕过登录验证的实验。如下图所示，先下载文件并解压运行：shiyanlou:~/ $ wget http://labfile.oss.aliyuncs.com/courses/876/sql2.tar.gzshiyanlou:~/ $ tar -zxvf sql2.tar.gzshiyanlou:~/ $ cd sql2shiyanlou:~/ $ sudo apt-get update shiyanlou:~/ $ ./deploy.sh 进入 Firefox 浏览器，输入网址 : localhost/sql2 , 按照下图所示顺序，初始化数据：[图片上传中。。。（16）][图片上传中。。。（17）][图片上传中。。。（18）][图片上传中。。。（19）]准备工作完成之后，我们进入首页发现这是一个普通的登录页面，只要输入正确的用户名和密码就能登录成功。我们先尝试随意输入用户名 123 和密码 123 登录：[图片上传中。。。（20）]从错误页面中我们无法获取到任何信息。看看后台代码如何做验证的：[图片上传中。。。（21）]实际执行的操作时：select * from users where username=’123’ and password=’123’ 当查询到数据表中存在同时满足 username 和 password 字段时，会返回登录成功。按照第一个实验的思路，我们尝试在用户名中输入 123’ or 1=1 #, 密码同样输入 123’ or 1=1 # ：[图片上传中。。。（22）][图片上传中。。。（23）]为什么能够成功登陆呢？因为实际执行的语句是：select * from users where username=’123’ or 1=1 #’ and password=’123’ or 1=1 #’ 按照 Mysql 语法，# 后面的内容会被忽略，所以以上语句等同于（实际上密码框里不输入任何东西也一样）：select * from users where username=’123’ or 1=1 由于判断语句 or 1=1 恒成立，所以结果当然返回真，成功登录。我们再尝试不使用 # 屏蔽单引号，采用手动闭合的方式：我们尝试在用户名中输入 123’ or ‘1’=’1, 密码同样输入 123’ or ‘1’=’1 （不能少了单引号，否则会有语法错误）：[图片上传中。。。（24）][图片上传中。。。（25）]实际执行的 Sql 语句是：select * from users where username=’123’ or ‘1’=’1’ and password=’123’ or ‘1’=’1` 看到了吗？两个 or 语句使 and 前后两个判断永远恒等于真，所以能够成功登录。还有很多其他 Mysql 语句可以巧妙的绕过验证，同学们可以发散自己的思维进行尝试。五、判断 Sql 注入点通常情况下，可能存在 Sql 注入漏洞的 Url 是类似这种形式 ：http://xxx.xxx.xxx/abcd.php?id=XX 对 Sql 注入的判断，主要有两个方面：判断该带参数的 Url 是否存在 Sql 注入？如果存在 Sql 注入，那么属于哪种 Sql 注入？ 可能存在 Sql 注入攻击的 ASP/PHP/JSP 动态网页中，一个动态网页中可能只有一个参数，有时可能有多个参数。有时是整型参数，有时是字符串型参数，不能一概而论。总之只要是带有参数的 动态网页且此网页访问了数据库，那么就有可能存在 Sql 注入。如果程序员没有足够的安全意识，没有进行必要的字符过滤，存在SQL注入的可能性就非常大。5.1 判断是否存在 Sql 注入漏洞最为经典的单引号判断法：在参数后面加上单引号,比如:http://xxx/abc.php?id=1&#39; 如果页面返回错误，则存在 Sql 注入。原因是无论字符型还是整型都会因为单引号个数不匹配而报错。（如果未报错，不代表不存在 Sql 注入，因为有可能页面对单引号做了过滤，这时可以使用判断语句进行注入，因为此为入门基础课程，就不做深入讲解了）5.2 判断 Sql 注入漏洞的类型通常 Sql 注入漏洞分为 2 种类型：数字型字符型 其实所有的类型都是根据数据库本身表的类型所产生的，在我们创建表的时候会发现其后总有个数据类型的限制，而不同的数据库又有不同的数据类型，但是无论怎么分常用的查询数据类型总是以数字与字符来区分的，所以就会产生注入点为何种类型。[图片上传中。。。（26）]5.2.1 数字型判断：当输入的参 x 为整型时，通常 abc.php 中 Sql 语句类型大致如下：select * from &lt;表名&gt; where id = x 这种类型可以使用经典的 and 1=1 和 and 1=2 来判断：Url 地址中输入 http://xxx/abc.php?id= x and 1=1 页面依旧运行正常，继续进行下一步。 Url 地址中继续输入 http://xxx/abc.php?id= x and 1=2 页面运行错误，则说明此 Sql 注入为数字型注入。 原因如下：当输入 and 1=1时，后台执行 Sql 语句：select * from &lt;表名&gt; where id = x and 1=1 没有语法错误且逻辑判断为正确，所以返回正常。当输入 and 1=2时，后台执行 Sql 语句：select * from &lt;表名&gt; where id = x and 1=2 没有语法错误但是逻辑判断为假，所以返回错误。我们再使用假设法：如果这是字符型注入的话，我们输入以上语句之后应该出现如下情况：select from &lt;表名&gt; where id = ‘x and 1=1’ select from &lt;表名&gt; where id = ‘x and 1=2’ 查询语句将 and 语句全部转换为了字符串，并没有进行 and 的逻辑判断，所以不会出现以上结果，故假设是不成立的。5.2.2 字符型判断：当输入的参 x 为字符型时，通常 abc.php 中 SQL 语句类型大致如下：select * from &lt;表名&gt; where id = ‘x’ 这种类型我们同样可以使用 and ‘1’=’1 和 and ‘1’=’2来判断：Url 地址中输入 http://xxx/abc.php?id= x’ and ‘1’=’1 页面运行正常，继续进行下一步。 Url 地址中继续输入 http://xxx/abc.php?id= x’ and ‘1’=’2 页面运行错误，则说明此 Sql 注入为字符型注入。 原因如下：当输入 and ‘1’=’1时，后台执行 Sql 语句：select * from &lt;表名&gt; where id = ‘x’ and ‘1’=’1’ 语法正确，逻辑判断正确，所以返回正确。当输入 and ‘1’=’2时，后台执行 Sql 语句：select * from &lt;表名&gt; where id = ‘x’ and ‘1’=’2’ 语法正确，但逻辑判断错误，所以返回正确。同学们同样可以使用假设法来验证。六、 总结sql注入常用技术有段还包括：采用非主流通道技术避开输入过滤技术使用特殊的字符强制产生错误使用条件语句利用存储过程推断技术…….. 内容转载自实验楼]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java环境问题]]></title>
    <url>%2FJava%2F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[开发工具快捷键(Mac)12345678输入ps(public static的缩写)可以生成main方法和其他4个方法ctrl+D复制当前行(有时没用？光标定位句首，ctrl+K，再粘贴)option+enter引入包ctrl+J查看方法说明win+回退键 删除当前行option+enter快速生成构造方法等ctrl+I实现父类接口ctrl +O重写父类方法 启动Tomcat报错Error running Tomcat7.0.52: Address localhost:1099 is already in use 或者是 java.rmi.server.ExportException: Port already in use: 1099 ，表示1099端口被其他进程占用了。解决方法： win+R，运行，输入cmd，进入命令提示符（管理员） 输入netstat -aon | findstr 1099，找到占用1099端口的进程ID：PID 输入taskkill -f -pid PID 重启Tomcat idea设置UTF编码 idea安装bin目录下，idea64.exe.vmoptions或者idea.exe.vmoptions（32位），添加-Dfile.encoding=UTF-8 setting中设置file Encoding全为utf-8 tomcat设置 最后pom.xml,由于idea中maven的配置优先 org.apache.maven.plugins maven-surefire-plugin 2.12.4 once -Dfile.encoding=UTF-8]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>javaIDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Linux]]></title>
    <url>%2FLinux%2Flinux%2F</url>
    <content type="text"><![CDATA[性能查看命令java相关ps -ef | grep java 找所有有关“java”的进程ps -efL | grep [PID] | wc -l 查看某个进程创建的线程数jmap -histo [pid] 按照对象内存大小排序 注意会导致full gc 内存 free 12345free [－b －k －m][－o] [－s delay][－t] [－V]－b －k －m：分别以字节（KB、MB）为单位显示内存使用情况。－s delay：显示每隔多少秒数来显示一次内存使用情况。－t：显示内存总和列。 －o：不显示缓冲区调节列。和top命令相比，它的优点是使用简单，并且只占用很少的系统资源。 vmstat 123456789101112131415vmstat 3(间隔时间) 100(监控次数)eg:[root@iZbp10fstdmbee21wif5ngZ 2018-02-26]# vmstat 3 100procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 399392 220280 6405804 0 0 1 4 1 2 1 0 98 0 0 0 0 0 398648 220280 6405960 0 0 0 25 2725 2284 2 0 98 0 0 0 0 0 398648 220280 6406036 0 0 0 91 2652 2255 2 0 97 0 0 0 0 0 398384 220280 6406080 0 0 0 112 2539 2180 2 0 98 0 0 1 0 0 398352 220280 6406184 0 0 0 0 2724 2230 2 0 98 0 0 r：等待在CPU资源的进程数。这个数据比平均负载更加能够体现CPU负载情况。如果这个数值大于机器CPU核数，那么机器的CPU资源已经饱和。si, so：交换区写入和读取的数量。如果这个数据不为0，说明系统已经在使用交换区（swap），机器物理内存已经不足。us, sy, id, wa, st：这些都代表了CPU时间的消耗，它们分别表示用户时间（user）、系统（内核）时间（sys）、空闲时间（idle）、IO等待时间（wait）和被偷走的时间（stolen，一般被其他虚拟机消耗）。一般情况下，如果用户时间和系统时间相加非常大，CPU处于忙于执行指令。如果IO等待时间很长，那么系统的瓶颈可能在磁盘IO。 top 网络 sar12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849sar -n &#123; DEV | EDEV | NFS | NFSD | SOCK | ALL &#125;DEV显示网络接口信息，EDEV显示关于网络错误的统计数据，NFS统计活动的NFS客户端的信息，NFSD统计NFS服务器的信息，SOCK显示套接字信息，ALL显示所有5个开关[root@iZbp10fstdmbee21wif5ngZ 2018-02-26]# sar -n SOCK 2 10Linux 3.10.0-514.6.2.el7.x86_64 (iZbp10fstdmbee21wif5ngZ) 02/27/2018 _x86_64_ (8 CPU)05:07:33 PM totsck tcpsck udpsck rawsck ip-frag tcp-tw05:07:35 PM 265 163 4 0 0 1205:07:37 PM 265 163 4 0 0 12totsck:使用的套接字总数量tcpsck:使用的TCP套接字数量udpsck:使用的UDP套接字数量rawsck:使用的raw套接字数量ip-frag:使用的IP段数量[root@iZbp10fstdmbee21wif5ngZ 2018-02-26]# sar -n DEV 2 10Linux 3.10.0-514.6.2.el7.x86_64 (iZbp10fstdmbee21wif5ngZ) 02/27/2018 _x86_64_ (8 CPU)05:12:43 PM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s05:12:45 PM eth0 535.50 397.00 58.26 67.17 0.00 0.00 0.0005:12:45 PM eth1 11.50 13.00 4.18 2.49 0.00 0.00 0.0005:12:45 PM lo 1.50 1.50 0.09 0.09 0.00 0.00 0.00IFACE：LAN接口rxpck/s：每秒钟接收的数据包txpck/s：每秒钟发送的数据包rxbyt/s：每秒钟接收的字节数txbyt/s：每秒钟发送的字节数rxcmp/s：每秒钟接收的压缩数据包txcmp/s：每秒钟发送的压缩数据包rxmcst/s：每秒钟接收的多播数据包[root@iZbp10fstdmbee21wif5ngZ 2018-02-26]# sar -n EDEV 2 10Linux 3.10.0-514.6.2.el7.x86_64 (iZbp10fstdmbee21wif5ngZ) 02/27/2018 _x86_64_ (8 CPU)05:13:47 PM IFACE rxerr/s txerr/s coll/s rxdrop/s txdrop/s txcarr/s rxfram/s rxfifo/s txfifo/s05:13:49 PM eth0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.0005:13:49 PM eth1 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00IFACE：LAN接口rxerr/s：每秒钟接收的坏数据包txerr/s：每秒钟发送的坏数据包coll/s：每秒冲突数rxdrop/s：因为缓冲充满，每秒钟丢弃的已接收数据包数txdrop/s：因为缓冲充满，每秒钟丢弃的已发送数据包数txcarr/s：发送数据包时，每秒载波错误数rxfram/s：每秒接收数据包的帧对齐错误数rxfifo/s：接收的数据包每秒FIFO过速的错误数txfifo/s：发送的数据包每秒FIFO过速的错误数 磁盘 iostat(具体查看manual)12345678eg.iostat -d -k 1 10 #查看TPS和吞吐量信息iostat -d -x -k 1 10 #查看设备使用率（%util）、响应时间（await）iostat -c 1 10 #查看cpu状态[root@iZbp10fstdmbee21wif5ngZ 2018-02-26]# iostat -d -x -k 1 10Linux 3.10.0-514.6.2.el7.x86_64 (iZbp10fstdmbee21wif5ngZ) 02/27/2018 _x86_64_ (8 CPU)Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.01 4.32 0.51 2.99 18.01 32.07 28.56 0.04 11.71 60.41 3.34 0.73 0.26 其他命令 grep1234567891011121314151617181920参数： -R 递归 -w 按单词查找 -l 列出文件名 -i 忽略大小写 --exclude= 排除 --exclude-dir 排除目录 -n 输出行号 -v 反向，即不包含eg.搜索内容包含指定字符串的文件 grep -s xxx /etc/* grep -R xxx /etc/* 包含子目录递归搜索 grep -Rw xxx /etc/* w-不会查找出包含xxxy的 grep -Rl xxx /etc/* 只输出文件名 grep -Ril xxx /etc/* 忽略大小写 grep -Ril xxx /etc/*.conf grep -Ril --exclude=\*.conf xxx /etc/* .conf文件不查找 grep --exclude-dir=/etc/grub.d -Rwl xxx /etc/* 排除/etc/grub.d目录 grep -Rni xxx /etc/*.conf n-输出字符串所在行行号 grep -Rlv xxx /etc/* 查找出所有不包含xxx的文件 VIM除了基本的会计键外，可以通过修改vim的配置文件实现编译运行程序(在 VimScript 中函数名必须以大写字母开头，否则 Vim 将提示错误；exec 关键字之后的都会在Vim 的命令模式下执行) 类似地： autocmd 实现这个，执行不同程序设计语言编译出的代码。 发行版 Ubuntu，已经不用了，经常会有bug和包的冲突，可定制性也不高。 爱上archlinux的原因 档案安装Wiki一步步装完archlinux的时候，你会惊讶于这个OS的勇气，始终坚持Keep simple的理念。呈现在你面前的只有一个虚拟终端。这其实意味着你需要付出更多的努力，但是却能保证打造出你最喜欢的系统，真正属于你的。 如果你还不够厉害（just like me），安装显卡驱动和xorg，再配上一个awesome或者其他的窗口管理器，就可以开始你的探险之旅了。 推荐给你的软件 vimfx 一款用vim方式操作firefox（pacman -S flashplugin安装flash）的插件。 zsh 一款好用的终端。 awesome主题 awesome-copycats等。 未完待续 问题记录：1.bios中没有arch引导项或选择arch后，grub 进入rescue模式，提示unknown file system 可以通过easyUEFI，管理efi启动项 在grub rescue模式中，也可以通过输入以下命令进入Linux系统 ls ls 各个分区，找到文件系统为fat的启动分区，unknown即不是（diskgenius辅助） set root=(hd1，gpt5) 设置启动分区 prefix= /grub （x86_64-efi所在的目录） insmod normal以上步骤没错的话，输入以下命令可进入grub菜单，否则是这两个参数有错 normal 按e编辑启动项为刚刚的分区，ctrl+x引导，最后进入系统后修改grub.cfg(用grub-mkconfig -o /boot/grub/grub.cfg自动生成)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2FJava%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java基础 基本数据类型 Name 字节数 初始值 byte 1 0 char 2 空格 short 2 0 int 4 0 float 4 0.0f long 8 0L double 8 0.0d char 2 空格 boolean 不明确 false 获得变量类型：1.System.out.println(TypeToolsTest2.class.getDeclaredField(“ii”).getType()); //成员变量2.System.out.println(Integer.class.isInstance(ii));3.泛型T.getClass().getName(); Java 会对 -128~127 的整数进行缓存 因此Integer a=128;Integer b=128;xx c=127;xx d=127 a!=b but c==d (IntegerCache.class) == 它比较的是对象的地址;equals 比较的是对象的内容 IO: BufferedReader br = new BufferedReader(new InputStreamReader(System.in));br.read();/br.readLine(); 类的实例化顺序：父类static，子类static，父类普通代码，父类构造，子类普通，子类构造 强引用：用关键词new出来的对象，强引用锁指向的对象在任何时候都不会被回收 ，即使内存不足，抛出错误。 集合：根接口Collection，List（有序可重复）,Set（无序不重复）接口都继承他。Map是单独的。 LinkedList：底层用双链表实现:增加删除效率高 ArrayList：底层用数组实现:查找效率高 Vector：实现了一个动态数组。和ArrayList相似，但是有以下不同：vector是同步的； vector包含了许多传统方法，或者只是需要一个可以改变大小的数组的情况。 Stack:先进后出 HashSet:HashSet不存入重复元素的规则.使用hashcode和equals LinkedHashSet:是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法 TreeSet:让存入的元素自定义比较规则;给TreeSet指定排序规则 7.HashMap和HashSet的区别 前者可以接受键和值为null，线程不安全，单线程效率高；后者线程安全，Java5后可以由CurrentHashMap替代。前者不能保证数据的顺序随着时间的推移不变。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2Fbootstrap%2F</url>
    <content type="text"><![CDATA[1.栅格系统总共12列，col-xs-6 col-sm-3 col-md（超小屏幕，小，中等）占的列宽12345678910&lt;div class="page-header"&gt; &lt;h1&gt;案例:Responsive column resets&lt;/h1&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-xs-6 col-sm-3"&gt;.col-xs-6 .col-sm-3(通过调整浏览器的宽度或在手机上即可查看这些案例的实际效果。)&lt;/div&gt; &lt;div class="col-xs-6 col-sm-3"&gt;.col-xs-6 .col-sm-3&lt;/div&gt; &lt;div class="clearfix visible-xs"&gt;&lt;/div&gt; &lt;div class="col-xs-6 col-sm-3"&gt;.col-xs-6 .col-sm-3&lt;/div&gt; &lt;div class="col-xs-6 col-sm-3"&gt;.col-xs-6 .col-sm-3&lt;/div&gt;&lt;/div&gt; 超小效果：不加，超小效果： 2.列偏移1234567891011121314&lt;div class="page-header"&gt; &lt;h1&gt;案例:列偏移&lt;/h1&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-md-4"&gt;.col-md-4&lt;/div&gt; &lt;div class="col-md-4 col-md-offset-4"&gt;.col-md-4 .col-md-offset-4&lt;/div&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-md-3 col-md-offset-3"&gt;.col-md-3 .col-md-offset-3&lt;/div&gt; &lt;div class="col-md-3 col-md-offset-3"&gt;.col-md-3 .col-md-offset-3&lt;/div&gt;&lt;/div&gt;&lt;div class="row"&gt; &lt;div class="col-md-6 col-md-offset-3"&gt;.col-md-6 .col-md-offset-3&lt;/div&gt;&lt;/div&gt; 效果：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2FJava%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[单链表逆置123456789101112131415161718192021public void reverseNodeList() &#123; //创建单链表9,8,7...0 Node curr=null;//初始化尾节点为空 for(int i=0;i&lt;10;i++)&#123; Node tmp=new Node(curr,i); curr=tmp; &#125; //逆转 Node prev=null;//前一个节点默认为空 while (curr!=null)&#123; if(curr==null||curr.next==null) &#123; curr.next=prev;//如果当前节点或他的下一个节点为空，就使他指向前一个节点 break;//结束，否则极易造成死循环 &#125; Node tmp=curr.next;//保存当前节点的下一个节点，作为下次循环的curr curr.next=prev;//当前节点指向前一个节点 prev=curr;//当前节点变下一次循环的前一个节点 curr=tmp; &#125;&#125; 判断单链表相交问题a：两链表都是没环的123问题a：1.因为都是单链表，所以在相交之后，相交点之后都是一样的节点，最后一个节点也一定是一样的(类推)2.将A的尾节点指向b的头结点，B循环到尾节点，如果是b的头结点，也是证明最后一个节点是一样的 问题b：两链表环的情况不知道先用追逐法判断单链表是否有环12判断有环的就是p0和p1都指向头结点，然后每次1走一步，b走两步，看走到的点是不是相同(可以这么去理解，有n个站台，a每次走一个站台，b每次走两个，如果这是个线性的那么b永远在a前面，如果有环，就是b得往回走，那么a，肯定是会相遇的，会有可能不相遇吗？如果b不是走两步的话，是有可能的，b的步伐太大，正好跳过了相遇点，但是每次走两步，假设跳过去相遇点，那么就应该是相遇点的前一个节点，那么相遇点实际上就有两个方向了，这就与单链表相矛盾了) 3种情形，都没环就是问题a，1个有环1个无环不可能相交，两个都有环还相交，环一定是共有的，即a环的相遇点在b的环上(记住吧) 找出第一个相交点 如果都没环（相交类比成一个Y字型），同样A的尾节点指向b的头结点，转换成用追逐法求环的那个偶遇点问题 剩下两个都有环的情况，计算出两链表的长度lA、lB，（环的长度和环到入口点长度之和就是链表长度）如果lA&gt;lB，则链表A指针先走lA-lB，然后链表B指针开始走，两者相遇的点就是相交点如果lB&gt;lA，则链表B指针先走lB-lA，然后链表A指针开始走，两者相遇的点就是相交点 一、排序排序分内部排序和外部排序（需不需要访问外存）排序算法的稳定是值排序后 2 个相等键值的顺序和排序之前它们的顺序相同 1.冒泡排序（n^2,最好n,最差n^2,内部稳定）1234567891011121314151617//我自己的，理解更合自己的胃口 boolean noSwarp=true; int[] b=&#123;8,5,5,7,8&#125;; for(int i=0;i&lt;b.length-1;i++)&#123; noSwarp=true; for(int j=b.length-1;j&gt;i;j--)&#123; if (b[j]&lt;b[j-1]) &#123; int tmp=b[j]; b[j]=b[j-1]; b[j-1]=tmp; noSwarp=false; &#125; &#125; if(noSwarp)&#123; break; &#125; &#125; 12345678910111213141516171819202122232425262728public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 2.选择排序（n^2,,内部不稳定）1234567891011121314151617181920212223242526272829public class SelectionSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; &#125; &#125; return arr; &#125;&#125; 3.插入排序（n^2,最好n,最差n^2,内部稳定）1234567891011121314151617181920212223242526272829public class InsertSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; return arr; &#125;&#125; 4.希尔排序（以插入排序为基础）1234567891011121314151617181920212223242526272829public class ShellSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int gap = 1; //选择合适的步长 while (gap &lt; arr.length) &#123; gap = gap * 3 + 1; &#125; while (gap &gt; 0) &#123; for (int i = gap; i &lt; arr.length; i++) &#123;//从第一组的第二个数开始 int tmp = arr[i];//保存当前要插入的值 int j = i - gap;//循环调整有序组内元素位置 while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = tmp; &#125; gap = (int) Math.floor(gap / 3); &#125; return arr; &#125;&#125; 5.快速排序（分治的思想）1234567891011121314151617181920212223242526272829303132public class QuickSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125; //分区算法！ private int partition(int[] arr, int left, int right) &#123; // 设定基准值（pivot）为最左边的数字 int pivot = left; int index = pivot + 1;//index表示小于基准值的右边界索引+1，初始化为 left+1 for (int i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123;//大于基准值时直接过，不过index不再累加，等找到下一个小于基准值的，再交换 swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1);//最后将基准值和小于基准值的右边界元素交换 return index - 1; &#125;&#125; 6.堆排序Math.floor(n/2)的位置开始，不断调整堆，调整堆的操作是个递归的操作（例如建造大顶堆设置索引largest=i，将其和子节点三者最大值和i的值进行对调，largest指向原最大值的位置，如果i=largest，则递归结束了（因为堆的下面是有序的了），否则继续递归该节点） 7.归并排序不断将原序列切分成两个子序列，调用 二、最长子序列和内容节选自 http://www.cnblogs.com/conw/p/5896155.html 1.O(N^3)的算法i从1到n，j从i到n，k从i到j算出以i，j为首尾的子序列的和，最大值即为所求。 2.O(N^2)的算法sum[i]表示从1到i的和，求出sum，从第i个数到第j个数的和即sum[j]-sum[i-1]。12345678910111213141516171819202122232425#include &lt;stdio.h&gt;//N是数组长度，num是待计算的数组，sum是数组前缀和，放在全局区是因为可以开很大的数组int N, num[16384], sum[16384];int main()&#123; //输入数据 scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) scanf("%d", &amp;num[i]); //计算数组前缀和 sum[0] = 0; for(int i = 1; i &lt;= N; i++) &#123; sum[i] = num[i] + sum[i - 1]; &#125; int ans = num[1]; //ans保存最大子序列和，初始化为num[1]能保证最终结果正确 //i和j分别是枚举的子序列的起点和终点 for(int i = 1; i &lt;= N; i++) &#123; for(int j = i; j &lt;= N; j++) &#123; int s = sum[j] - sum[i - 1]; if(s &gt; ans) ans = s; &#125; &#125; printf("%d\n", ans); return 0;&#125; 3.分治O(N*logN)1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;//N是数组长度，num是待计算的数组，放在全局区是因为可以开很大的数组int N, num[16777216];int solve(int left, int right)&#123; //序列长度为1时 if(left == right) return num[left]; //划分为两个规模更小的问题 int mid = left + right &gt;&gt; 1; int lans = solve(left, mid); int rans = solve(mid + 1, right); //横跨分割点的情况 int sum = 0, lmax = num[mid], rmax = num[mid + 1]; for(int i = mid; i &gt;= left; i--) &#123; sum += num[i]; if(sum &gt; lmax) lmax = sum; &#125; sum = 0; for(int i = mid + 1; i &lt;= right; i++) &#123; sum += num[i]; if(sum &gt; rmax) rmax = sum; &#125; //答案是三种情况的最大值 int ans = lmax + rmax; if(lans &gt; ans) ans = lans; if(rans &gt; ans) ans = rans; return ans;&#125;int main()&#123; //输入数据 scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) scanf("%d", &amp;num[i]); printf("%d\n", solve(1, N)); return 0;&#125; 4.动态规划O(N)我们用dp[n]表示以第n个数结尾的最大连续子序列的和，于是存在以下递推公式：dp[n] = max(0, dp[n-1]) + num[n]仔细思考后不难发现这个递推公式是正确的，则整个问题的答案是max(dp[m]) | m∈[1, N]。123456789101112131415161718192021222324#include &lt;stdio.h&gt;//N是数组长度，num是待计算的数组，放在全局区是因为可以开很大的数组int N, num[134217728];int main()&#123; //输入数据 scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) scanf("%d", &amp;num[i]); num[0] = 0; int ans = num[1]; for(int i = 1; i &lt;= N; i++) &#123; if(num[i - 1] &gt; 0) num[i] += num[i - 1]; else num[i] += 0; if(num[i] &gt; ans) ans = num[i]; &#125; printf("%d\n", ans); return 0;&#125; 没有创建另外的数组我感觉有点混乱… 5.又一个O(N)的算法。。。]]></content>
      <categories>
        <category>Java算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式]]></title>
    <url>%2FJava%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[六大原则 单一职责原理：一个类只负责一项职责。 里氏替换原则：劲量不要重写父类的已经实现了的方法，可以用接口等其他方法绕开。 依赖倒置原则：高层模块不应该依赖底层模块，二者应依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 接口隔离原则：客户端不应该依赖其他不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 迪米特法则：又叫做最小知道原则。就是一个类对自己依赖的类知道越少越好。 开闭原则：尽量通过扩展软件实体行为来实现变化。 可以分为三种：创建型、结构型和行为型 1.单例模式（singleton pattern）12345678910//饿汉public class EagerInitializedSingleton &#123; private static final EagerInitializedSingleton instance = new EagerInitializedSingleton(); //private constructor to avoid client applications to use constructor private EagerInitializedSingleton()&#123;&#125; public static EagerInitializedSingleton getInstance()&#123; return instance; &#125;&#125; 1234567891011121314//懒汉public class LazyInitializedSingleton &#123; private static LazyInitializedSingleton instance; private LazyInitializedSingleton()&#123;&#125; //加synchronized 就是线程安全的 public static synchronized LazyInitializedSingleton getInstance()&#123; if(instance == null)&#123; instance = new LazyInitializedSingleton(); &#125; return instance; &#125;&#125; 1234567891011//双重加锁public static ThreadSafeSingleton getInstanceUsingDoubleLocking()&#123; if(instance == null)&#123; synchronized (ThreadSafeSingleton.class) &#123; if(instance == null)&#123; instance = new ThreadSafeSingleton(); &#125; &#125; &#125; return instance;&#125; 123456789101112131415161718192021//使用反射则单例模式无效！public class ReflectionSingletonTest &#123; public static void main(String[] args) &#123; EagerInitializedSingleton instanceOne = EagerInitializedSingleton.getInstance(); EagerInitializedSingleton instanceTwo = null; try &#123; Constructor[] constructors = EagerInitializedSingleton.class.getDeclaredConstructors(); for (Constructor constructor : constructors) &#123; constructor.setAccessible(true);//important! instanceTwo = (EagerInitializedSingleton) constructor.newInstance(); break; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(instanceOne.hashCode()); System.out.println(instanceTwo.hashCode()); &#125;&#125; 2.观察者模式]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java设计模式</tag>
      </tags>
  </entry>
</search>
